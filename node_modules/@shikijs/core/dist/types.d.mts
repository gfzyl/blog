import { Root } from 'hast';
import { I as IGrammar, T as ThemeInput, g as SpecialTheme, L as LanguageInput, S as SpecialLanguage, h as ThemeRegistrationAny, m as ThemeRegistrationResolved, s as LanguageRegistration, C as CodeToHastOptions, r as ResolveBundleKey, a as CodeToTokensOptions, b as TokensResult, c as CodeToTokensBaseOptions, d as ThemedToken, e as CodeToTokensWithThemesOptions, f as ThemedTokenWithVariants, G as GrammarState } from './chunk-tokens.mjs';
export { A as AnsiLanguage, $ as Awaitable, B as BundledHighlighterOptions, t as BundledLanguageInfo, Q as BundledThemeInfo, y as CodeOptionsMeta, v as CodeOptionsMultipleThemes, u as CodeOptionsSingleTheme, w as CodeOptionsThemes, x as CodeToHastOptionsCommon, o as CodeToHastRenderOptions, z as CodeToHastRenderOptionsCommon, a4 as DecorationItem, a3 as DecorationOptions, a6 as DecorationTransformType, D as DynamicImportLanguageRegistration, O as DynamicImportThemeRegistration, X as FontStyle, H as HighlighterCoreOptions, M as MaybeArray, a0 as MaybeGetter, a1 as MaybeModule, a7 as Offset, a8 as OffsetOrPosition, P as PlainTextLanguage, k as Position, E as RawGrammar, F as RawTheme, J as RawThemeSetting, R as RequireKeys, a5 as ResolvedDecorationItem, a9 as ResolvedPosition, q as ShikiTransformer, _ as ShikiTransformerContext, n as ShikiTransformerContextCommon, Z as ShikiTransformerContextMeta, p as ShikiTransformerContextSource, a2 as StringLiteralUnion, N as ThemeRegistration, K as ThemeRegistrationRaw, V as ThemedTokenExplanation, U as ThemedTokenScopeExplanation, W as TokenBase, j as TokenStyles, i as TokenizeWithThemeOptions, Y as TransformerOptions } from './chunk-tokens.mjs';
export { L as LoadWasmOptions, a as WebAssemblyInstance, W as WebAssemblyInstantiator } from './chunk-engines.mjs';

interface Grammar extends IGrammar {
    name: string;
}

/**
 * Internal context of Shiki, core textmate logic
 */
interface ShikiInternal<BundledLangKeys extends string = never, BundledThemeKeys extends string = never> {
    /**
     * Load a theme to the highlighter, so later it can be used synchronously.
     */
    loadTheme: (...themes: (ThemeInput | BundledThemeKeys | SpecialTheme)[]) => Promise<void>;
    /**
     * Load a language to the highlighter, so later it can be used synchronously.
     */
    loadLanguage: (...langs: (LanguageInput | BundledLangKeys | SpecialLanguage)[]) => Promise<void>;
    /**
     * Get the registered theme object
     */
    getTheme: (name: string | ThemeRegistrationAny) => ThemeRegistrationResolved;
    /**
     * Get the registered language object
     */
    getLanguage: (name: string | LanguageRegistration) => Grammar;
    /**
     * Set the current theme and get the resolved theme object and color map.
     * @internal
     */
    setTheme: (themeName: string | ThemeRegistrationAny) => {
        theme: ThemeRegistrationResolved;
        colorMap: string[];
    };
    /**
     * Get the names of loaded languages
     *
     * Special-handled languages like `text`, `plain` and `ansi` are not included.
     */
    getLoadedLanguages: () => string[];
    /**
     * Get the names of loaded themes
     *
     * Special-handled themes like `none` are not included.
     */
    getLoadedThemes: () => string[];
    /**
     * Dispose the internal registry and release resources
     */
    dispose: () => void;
    /**
     * Dispose the internal registry and release resources
     */
    [Symbol.dispose]: () => void;
}
/**
 * Generic instance interface of Shiki
 */
interface HighlighterGeneric<BundledLangKeys extends string, BundledThemeKeys extends string> extends ShikiInternal<BundledLangKeys, BundledThemeKeys> {
    /**
     * Get highlighted code in HTML string
     */
    codeToHtml: (code: string, options: CodeToHastOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => string;
    /**
     * Get highlighted code in HAST.
     * @see https://github.com/syntax-tree/hast
     */
    codeToHast: (code: string, options: CodeToHastOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => Root;
    /**
     * Get highlighted code in tokens. Uses `codeToTokensWithThemes` or `codeToTokensBase` based on the options.
     */
    codeToTokens: (code: string, options: CodeToTokensOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => TokensResult;
    /**
     * Get highlighted code in tokens with a single theme.
     * @returns A 2D array of tokens, first dimension is lines, second dimension is tokens in a line.
     */
    codeToTokensBase: (code: string, options: CodeToTokensBaseOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => ThemedToken[][];
    /**
     * Get highlighted code in tokens with multiple themes.
     *
     * Different from `codeToTokensBase`, each token will have a `variants` property consisting of an object of color name to token styles.
     *
     * @returns A 2D array of tokens, first dimension is lines, second dimension is tokens in a line.
     */
    codeToTokensWithThemes: (code: string, options: CodeToTokensWithThemesOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => ThemedTokenWithVariants[][];
    /**
     * Get the last grammar state of a code snippet.
     * You can pass the grammar state to `codeToTokens` as `grammarState` to continue tokenizing from an intermediate state.
     */
    getLastGrammarState: (code: string, options: CodeToTokensBaseOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>) => GrammarState;
    /**
     * Get internal context object
     * @internal
     * @deprecated
     */
    getInternalContext: () => ShikiInternal;
}
/**
 * The fine-grained core Shiki highlighter instance.
 */
type HighlighterCore = HighlighterGeneric<never, never>;

export { CodeToHastOptions, CodeToTokensBaseOptions, CodeToTokensOptions, CodeToTokensWithThemesOptions, type Grammar, GrammarState, type HighlighterCore, type HighlighterGeneric, LanguageInput, LanguageRegistration, ResolveBundleKey, type ShikiInternal, SpecialLanguage, SpecialTheme, ThemeInput, ThemeRegistrationAny, ThemeRegistrationResolved, ThemedToken, ThemedTokenWithVariants, TokensResult };
