# 鸡翅Club项目专区

## 1.介绍一下你这个项目吧![](https://img.shields.io/badge/重要-red)

好的，面试官，接下来我来阐述一个这个项目的业务是什么。

这个项目是我跟随某位技术大牛一步一步从零到一落地实现的, 由于自己前端技术并不精通, 因此本项目我专门针对于后端业务的编写。项目的
**制作初衷** 是鉴于当下求职过程中同学们 **要针对面试题有一套系统的复习过程**
，但是市面上的题目和配套的答案质量参差不齐，也没有相应的社区供同学们讨论，于是本项目就应运而生了。

从整体的项目架构上来说，我们采用的是主流的微服务架构Spring Cloud
Alibaba，再利用docker容器管理主流的中间件提供专精的功能，主要实现的功能有刷题、练题、社区交流等。整个项目中从数据库表的设计起步，经过严格的技术选型、架构设计最终实现以上功能。但由于本人技术有限，项目现在的功能并不完善。

## 2. 你认为这个项目的难点和亮点是什么？![](https://img.shields.io/badge/重要-red)

::: tip 重点提醒

这个题目几乎必考, 背会

**亮点和难点是针对你自身的情况来设定的。讲的时候，讲出自信，逻辑自洽，这个环节会刷掉一些对自己项目都不了解的人，一问就是：我觉得我这个项目没什么亮点和难点。**

:::

好的，面试官，这个项目对于我来说还是有很大的挑战性的，在此过程中，我也成长和学习到了不少。

亮点和难点方面我主要从三个方面来阐述，一个是业务方面，一个是整体设计方面，一个是技术方面。

业务方面来说，虽说是跟随课程学习，但还是需要花时间理解项目的实现意义和各个业务之间的关系，比如，虽然CRUD这样的操作听着很简单，但是必须建立在非常熟悉业务的基础上。这一点我认为体现在未来工作中
**主要就是理解需求说明**，不断挖掘用户背后的真实需求点。

从整体设计方面，采用的是 **微服务架构** 的形式，**领域能力** 的方式进行 **驱动划分**
，采取了一个整洁一点的分层模型架构，目前划分出来，题目主数据、权限、文件、网关几个服务。每个服务之间解藕。整体采用的是springcloud
alibaba作为后端的技术框架，中间件相关的东西，用docker进行中间件的部署。相较于目前的市面上的技术，项目采取的架构是比较新的。

最后，功能实现的过程中在技术方面对我的提升是非常大的，也拓宽了自己的知识面。比如，我们做了 **网关gateway配合redis实现分布式的会话共享**， **基于threadlocal实现了整体用户上下文的打通**，**将一些设计模式融入到代码**中。

------

如果问到：

* **基于threadlocal实现了整体用户上下文的打通**：


* **网关gateway配合redis实现分布式的会话共享**：


* **将一些设计模式融入到代码**：

## 3.说说你这个项目的架构情况吧？

从整体部署情况上，因为是自己学习，所以只将服务搭建在一台服务器上，顺便连同着数据库、redis等中间件也都在这一台服务器上。如果考虑可用性等完全可以水平扩展，将服务部署在更多的服务器上。

前端项目可以配合nginx反向代理到网关服务，网关根据不同的请求类别打到不同的服务上。

## 4. 你在这里面主要负责哪些东西？![](https://img.shields.io/badge/重要-red)

好的，面试官。学习过程中，各个服务之间各有轻重，整个项目中我主要负责技术选型，框架的构建，**侧重于刷题模块的设计与开发**
（ps：记住这个地方要给面试官埋沟子，这块说的，让面试官有兴趣延伸）。

技术选型主要是评估用户量，服务器资源，选取最快能达成结果和比较主流的技术栈。

框架构建方面，也是学习到了DDD领域模型而不是传统的三层架构。虽然我没有非常专业、深刻的认识，但整体在coding的过程中
**对DDD有一些粗浅的领悟以及体会**：

刷题模块就是 从0到1 的设计与落地了。从需求沟通到业务建模到原型设计，数据库设计这些都是我来做的，最终开发进行落地。以上就是我负责的内容。

## 5. 浅谈技术选型？

技术选型主要是从几个方面来进行考虑的，需求背景，上手难易程度，技术生态等等。

整个项目是以学习为主，并不需要选取一些常见的框架业务做二次开发，而是完整的从0到1实现。整体上来说，整个项目的业务不是简单的一个两个，服务之间也有必要的关系，因此选取微服务cloud
alibaba的形式来进行开发。

数据库方面，存储的数据解构并不复杂，数据量也不会太大，因此直接使用mysql

缓存上用了redis

分布式搜索引擎就用了ElasticSearch

定时任务选择了xxl-job

## 6. 前后端的开发模式是什么样的？

项目采取的方式是前后端分离开发的模式，前后端通过 **接口文档配合原型** 来进行开发设计。

**整体的设计规范由后端的接口开发来定义**，后端编写接口文档要考虑到前端的展示能力，定义好接口的出入参之后，进行开发，文档用的是
apipost，进行团队的协作。

编写接口文档对接的时候，需要注意一下几点：

* 保证可理解性高，语义简单，定义好公共的出参格式。必填非必填等定义清晰，类型定义清晰
* 遵守原则：前端只负责进行渲染，尽可能的将逻辑进行后移，前端不要根据后端的参数做复杂的逻辑判断和处理
* 注重接口的性能

## 7. 这个刷题业务是怎么做的？![](https://img.shields.io/badge/重要-red)

::: tip 说明

既然上面提到了 **刷题业务是整个项目的核心业务**, 这一道题就需要认真准备

:::

先讲一下刷题业务的大概逻辑，刷题主要是为了方便看题库，题目是主要的信息。

题目会分为四个类型：单选、多选、判断和简答。在 **题型这块实践过程中扩展为工厂+策略的设计模式** 来做，这样做即使题型扩展，原先编写的代码也不需要修改。

为了方便查询题目，特别对题目做了 **分类和标签** 处理。其中分类表示大类，比如框架、数据库等等；而标签则对应更细的类型，一个题目可以属于多个标签，比如一道
mysql 的题目，既可以属于 mysql 标签，也可以属于基础标签，这就可以做难度的划分。除此之外，还有题目的解析。

为了方便精准查找，做了全文检索的高亮设计。

## 8. 你说其中用到了设计模式，这样设计有什么好处吗？![](https://img.shields.io/badge/中等-orange)

在目前的项目中，用了几处设计模式，第一块就是题目录入的时候，目前题型有四种，考虑到 **题型的可扩展性于是用工厂 + 策略模式**
进行处理，好处是，四个题型各写各的逻辑，互相解耦，互相没有任何影响，还可以扩展题型，通过在枚举中添加相应的类型，而不影响先前编写的业务代码。

另一处设计模式的使用，是 **文件相关的适配器模式**。在文件的 sdk 上封装一层
adapter，主要是为了操作底层文件的时候，不用处理任何的上层代码。上层业务无需进行任何修改，即可更换文件存储 oss。

## 9. 你这个项目的分层是怎么做的？

主要分为 **对外接口层**，**应用层**，**领域层**，**基础设施层**，**公共层**，**启动层**。

相较于传统的三层架构，这样来做模块分层 **更加的清晰，便于管理，每层只关注自身行为**。

* 对外接口层：主要是微服务之间的 api 接口提供，方便消费方进行引用调用。
* 应用层：放接口的入口，比如 controller 入口，mq 的消费，job 的启动。
* 领域层：放领域性的代码，比如新增题目能力，可能涉及很多原子，在领域层做组装，提供出去。
* 基础设施层：做最原子性的处理，主要是与 mysql，redis 等数据来源的交互，以及外部的 rpc 调用。
* 公共层：抽取所有层都需要的包及逻辑，便于复用。
* 启动层：单独抽取一个 starter，专注于启动配置。

## 10. 数据库密码加解密怎么做的？

数据库的密码加密主要是保证信息的安全性。直接使用了 **Druid**连接池的方式。利用 Druid提供的加密工具，先生成公钥和私钥，再将密码进行加密。

在项目配置文件进行配置，其中 Druid提供了一个 property，可以开启加密的使用，然后配置密钥。就实现了密码在配置文件的加密。

------

详细过程

在 Spring Boot 中使用 Druid 数据库连接池时，可以通过配置开启数据库连接信息的加解密功能，以保护数据库连接密码的安全。Druid
本身提供了加密和解密的功能，以下是具体的配置步骤。

### 1. 添加 Druid 依赖

首先，确保 `pom.xml` 中添加了 Druid 的依赖：

```xml

<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.8</version> <!-- 请使用最新版本 -->
</dependency>
```

### 2. 配置 Druid 连接池加密

Druid 提供了一种通过加密工具对数据库密码进行加密的方法。先使用 Druid 提供的加密工具生成加密后的密码。

#### 生成加密密码

运行以下代码来生成加密的数据库密码：

```java
import com.alibaba.druid.filter.config.ConfigTools;

public class DruidEncryptPassword {
    public static void main(String[] args) throws Exception {
        // 需要加密的数据库密码
        String password = "yourDatabasePassword";
        String[] keyPair = ConfigTools.genKeyPair(512);
       
        // 私钥
        System.out.println("Private Key: " + keyPair[0]);
        // 公钥
        System.out.println("Public Key: " + keyPair[1]);
        // 使用私钥加密后的密码
        System.out.println("Encrypted Password: " + ConfigTools.encrypt(keyPair[0], password));
    }
}
```

运行此程序后，将得到：

- 私钥：用于解密
- 公钥：用于加密
- 加密后的密码

将加密后的密码保存在 `application.yml` 文件中。

#### 3. 配置 Druid

接下来，可以在 `application.yml` 中配置 Druid 数据库连接池的相关参数，并使用加密后的密码。

**application.yml 示例**

```yaml
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/yourDatabase
      username: yourUsername
      # 使用加密后的密码
      password: "{cipher}加密后的密码"
      filters: stat,wall,config
      connection-properties: config.decrypt=true;config.decrypt.key=公钥
```

在上面的配置中：

- `{cipher}` 是密码加密的标记，用于告诉 Druid 这是一个加密后的密码。
- `config.decrypt=true` 表示开启解密功能。
- `config.decrypt.key=公钥` 需要配置公钥，以便 Druid 在运行时解密密码。

#### 4. 代码解密密码

如果需要在代码中手动解密密码，可以使用 Druid 提供的 `ConfigTools` 类：

```java
String encryptedPassword = "加密后的密码";
String publicKey = "公钥";
String decryptedPassword = ConfigTools.decrypt(publicKey, encryptedPassword);
System.out.println("Decrypted Password: " + decryptedPassword);
```

### 5. 验证配置

启动 Spring Boot 应用后，Druid 会使用提供的公钥来解密加密的数据库密码并进行连接。

## 11. 分类和标签这个业务是怎么做的？![](https://img.shields.io/badge/重要-red)

这个分类和标签的设计主要也是调研了一下需求，一开始我们设计的是一个分类对应一个标签，然后一个题目只能打一个标签，后来发现，比如
redis 为什么这么快，从分析上来看，属于缓存分类，属于 redis 和基础的两个标签。那么就要打破一对一的关系。其次就是标签为基础，不仅仅是
redis 下面的，也可以是其他分类下面的。所以做了一个标签池的概念，只和分类做关联，这样做之后，既方便了录题，也方便查询。其次就是题目与他们的关联关系，通过中间表来进行关联做，这样就打通了分类，标签，题目三者的关系。

## 12. 你说你封装了一些提效的组件，这块都有什么？

举一个例子，我们在做 es 的时候，发现无论是 data 操作还是传统的 client
组装起来还是很麻烦的。其中呢，又有大量的需要组装的重复代码。还有就是集群和索引切换的情况基于这种情况，就封装了一个
esclient，其中封装了常见的各种使用，通过入参，传入属性，可以去做不同的查询逻辑，比如高亮，模糊，精准搜索等等。同时将 es
多集群，多索引的情况，通过加载的形式，放入了工厂 map，涉及不同 service 的场景，直接传入 key 就可以取到 es
的链接。进行切换使用。这个小组件，在项目里面用起来十分的方便。

## 13. 自动部署你是怎么做的？![](https://img.shields.io/badge/中等-orange)

::: tip 说明

这道题我感觉自己有能力设立钩子,引面试官问这道题相关的内容

:::

自动部署主要是采用了 **Jenkins** 来做，通过 Jenkins 构建一个 maven 项目。

在 Jenkins 的系统工具里面配置好 maven、jdk 环境，用 git 插件拉取 gitee 上托管的代码，配置其中打包的 pom 文件位置。

然后，配置 maven 打包的命令。进行这几步后，就可以从 git 上拉取代码并进行打包，生成 jar 包，但是生成 jar
包启动还需要手动启动，这样很麻烦。于是就编写 shell 脚本将打包好的 jar 包，复制到自己设置的目录中进行统一管理，其实就是运行nohuo
java -jar这要用守护线程来启动服务。

## 14. 自动部署如何往多台服务器部署呢？

往多台服务器部署的能力主要是使用了 Jenkins 的一个插件 **publish over ssh**，当 Jenkins 服务器打包完成后，可以通过这个插件将
jar 包发送到不同的机器上，发送完毕后，还可以执行配置好的 shell 脚本，这样就实现了往多台机器自动部署，只需操作一个 Jenkins。

## 15. nacos 的动态配置原理是什么？

nacos 主要是 **长轮询** 的方式获取数据，client 也就是我们的服务会像 nacos 的 server
发送请求，判断数据是否有变更的情况。如果与本地的数据对比有变化则进行配置的更新，其中判断是否更新了采取的是整体加密后的 md5
串的对比。如果无变化，则证明无更新，有变化，则拉取最新的配置。

## 16. 搭建项目你是如何解决包冲突的问题和各种组件的兼容？

在最初进行选择的时候，比如 boot 与 cloudalibababa 的冲突适配问题，我们是先选择了 springboot 的版本，考虑再三觉得 2 还是比 3
更加成熟一点，3 可能有一些还没有适配上。于是我们选择了稳定的 2.4.2 版本。

然后再通过 springboot 给我们提供的组件选择，还有 **阿里云的脚手架工具**，只需要配置我们想要使用的微服务的组件，就能给出对应组件合适兼容的版本。

其次开发过程中可能有 maven 产生的包依赖的冲突，主要依靠的是 mavenhelper 插件，他可以帮助我们将整个 pom
梳理成树结构，同时冲突的会变成红色进行标注。方便我们找到冲突，还可以通过他直接操作排除，非常方便。

## 17. 鉴权模型你是如何设计的？![](https://img.shields.io/badge/重要-red)

基于角色把授权和用户的访问控制做结合。

用户就是系统的使用者。权限就比如用户我们对系统的操作以及数据的读写权限等等。

Role（角色）就是一组权限的集合。核心思想就是把 **角色** 和 **权限** 做关联，实现整体灵活访问，提高系统的安全性和管理性。

## 18. 权限数据你是放到了哪里？redis 吗？

<img src="https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1707878867889-2fd212f5-4932-49c6-8361-1568dbec3755.png" alt="img" style="zoom:67%;" />

是的。在微服务架构下的一个难题即 **会话信息同步**，**单机版的Session在分布式环境下一般不能正常工作**，我们选择了主流的
redis 来存储权限信息，配合了网关 gateway 实现权限接口，实现统一的鉴权处理，避免了与数据库频繁的交互。

------

::: warning 关于“单机版的Session在分布式环境下一般不能正常工作”

在分布式环境中，使用单机版的 Session 通常会出现问题，因为单机版 Session 依赖于将用户的会话数据存储在单个服务器的内存中，会话数据在不同服务器之间无法共享。

:::

## 19. 为什么选取 satoken 来作为权限框架？![](https://img.shields.io/badge/重要-red)

一方面是 **技术选型涉及的成本**，权限是每个项目都绕不开的，如何快速的接入，并且具备较好的扩展性，功能完备，是我们最开始需要考虑的。而satoken
十分轻量，功能齐全，学习成本低，可以快速上手。

另一方面是 **复杂性考虑**：Sa-Token 是一个轻量级 Java 权限认证框架，他能解决例如 
**登录认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权** 等一系列权限相关问题，正好符合我们的微服务分布式项目的场景。

无需实现任何接口，无需创建任何配置文件，只需要一句静态代码的调用，便可以完成会话登录认证。

## 20. token 机制的鉴权有什么好处？![](https://img.shields.io/badge/中等-orange)

说到 token 必须先说一下 **cookie**。传统的一般由 Cookie 完成，Cookie
有两个特性：可由后端控制写入，每次请求自动提交。这就使得我们在前端代码中，无需任何特殊操作，就能完成鉴权的全部流程。但是在app、小程序等前后端分离场景中，一般是没有
Cookie 这一功能的。

于是引入 token 这个概念。拆解出来主要是两步：

* 登录后，后端返回 token
* 前端请求带着 token，将 token 放到 header 里面

实现了 token 的传递之后，token 的生成过程可以包含各种信息，比如用户的用户名，相关的权限，都可以包含在里面，这样一个 token
就可以帮助我们带来很多信息，鉴权等功能也就非常容易做了，同时还解决了 cookie 问题。

## 21. gateway 网关你是怎么设计的？![](https://img.shields.io/badge/重要-red)

gateway 网关，作为项目的整个流量入口，目前主要实现了路由，负载，统一鉴权，全局过滤器，异常处理这些功能。

路由和负载承载了后台微服务的 uri 转发和前缀匹配。

统一鉴权主要是配合 satoken，**在 gateway 集成 redis，同时实现 satoken 提供的权限读取接口**
，在其中自定义读取逻辑，实现鉴权的校验。还实现了登录拦截器，用于传递 loginId 到微服务中，借助了 header 的传递。

## 22. 分布式会话的鉴权在微服务中的是怎么做的？![](https://img.shields.io/badge/重要-red)

分布式会话鉴权的 **重点主要是如何获取到权限数据，然后进行校验处理**。

在这里采取的方法是：直接从 redis 中获取缓存的权限数据，也就是说完全信任缓存。实际项目中必须要求redis的高可用性。

::: details 为什么？

为什么可以完全信任缓存？

考虑到当前项目主要是学习为主，实际并不会有过高的并发量，因此完全相信缓存而简化

:::

## 23. gateway 如何实现的全局异常处理？![](https://img.shields.io/badge/重要-red)

::: tip 强调

简历上写了,必须背背

:::

gateway 的全局异常处理主要需要 **实现一个接口ErrorWebExceptionHandler**，实现其中的 **handle** 方法，在方法内我们能获取到其中
**request 与 response**，webhandler 会帮助我们拦住所有异常的情况。然后可以做拦截的进一步处理，比如更改状态码，状态错误信息等等。最后通过
response 可以将其返回出去。

## 24. 用户登录的密码加密你做了吗？

要做加密，即使拿到了密码信息， 也不能还原原始的密码。

加密主要有摘要加密，对称加密，非对称加密。

我们采用的是 md5 摘要配合加盐。摘要算法比如 md5，光加密 123456，结果都是一样的，如果是破解的库里正好有这个 md5 就很容易知道逆向是
123456。来一手加盐。盐是随机的字符串，他来与原密码进行一波二次加密。这样获取到的很难破解出来。

网上有许多md5破译的密码信息，一些常见的密码很容易有破译结果。

## 25. 缓存与数据一致性，你有什么样的理解吗？

没啥好说的直接看鸡哥https://www.yuque.com/jingdianjichi/kwag7a/rk2bbdr71lhntod8

## 26. 你是如何对接公众号登录的？![](https://img.shields.io/badge/重要-red)

::: tip 说明

这个问题可能会和Sa-Token挂钩

:::

首先，在一开始的数据表设计是有用户名和密码的逻辑的，但是现在微信扫码的方式很方便，其次，微信公众号的方式 **每个用户都有其唯一的
openId** 作为唯一标识，也能方便登录，所以引入这种方式

整体流程主要是用户扫公众号码，扫码后后台随机回复一个验证码，用户在登陆扫码后输入这个验证码点击登录，此时 redis 中就存储了
`openId + 验证码` 的结构。

如果是首次登陆即为注册，进入注册的模块同时关联一些基础默认的角色和权限，其他情况下就是登陆操作，这时角色和权限就是该用户对应的角色和权限，
**到这里，我们就实现了网关的统一鉴权**。

由于每个用户都有自己唯一的 openId, 结合 Sa-Token 登录的方式，我们将 openId 传入，这样每个用户都有自己独特的状态的
token，之后所有的请求都会带着这个 token， 所有的请求都根据该 token 的状态来鉴权判定是否执行。

## 27. 你是如何监听用户发给公众号的消息的？

**主要是对接公众号的回调消息平台配置**。重点主要分为三步：填写服务器配置，验证服务器地址的有效性，依据接口文档实现业务逻辑。

在公众号配置界面填写服务器地址（URL）、Token和EncodingAESKey

* URL是我们编写的微信后端服务接口，我们把它部署到服务器上，或者用内网穿透工具实现

* Token可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）

* EncodingAESKey手动填写或随机生成，将用作消息体加解密密钥。

验证消息的确来自微信服务器：**微信服务器将发送GET请求** 到填写的服务器地址URL（**其实就是我们自己写的微信的后端服务**
）上，GET请求携带参数有签名，内容，时间戳之类的，后台服务要通过一样的加密形式来进行校验。

依据接口文档实现业务逻辑：验证URL有效性成功后即接入生效，用户每次向公众号发送消息，开发者填写的服务器配置URL将得到微信服务器推送过来的消息和事件，开发者可以依据自身业务逻辑进行响应，如回复消息。

微信的消息是XML结构的，可以观察微信消息的结构，提取关键字从而实现发送和接受消息

## 28. 回调消息的验证校验是如何做的？

开发者通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

1）将token、timestamp、nonce三个参数进行字典序排序

2）将三个参数字符串拼接成一个字符串进行sha1加密

3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信

## 29. 多线程你是在哪里用到的，咋用的？![](https://img.shields.io/badge/重要-red)

多线程主要是用于前端的 **分类请求**，一开始每个分类都是轮询获取标签，比如有 10 个分类，要串行调用 10 次，速度特别的慢。

于是将逻辑进行后移，将 **分类换成多线程并发获取**，然后统一进行组装，再返回给前端,提高了性能。

主要用到了 **futuretask** 来进行实现，同时 **自定义线程池**，而不是使用 jdk 提供的默认线程池。

## 30. 自定义线程工厂的意义是什么？![](https://img.shields.io/badge/重要-red)

自定义线程工厂好处多多，比如:

* **可以设置自定义的线程名**，方便我们开发调试，问题日志查找及定位。

* 可以设置守护线程。
* 可以设置 **线程优先级**
* 可以处理未捕获的异常：在执行一个任务时，线程可能会由于未捕获的异常而终止，默认处理是将异常打印到控制台。但这种处理方式有时并非你所想要的，存放如文件或者db会更合适。

## 31.线程池的数量应该设置多少

**没有固定答案，先设定预期，比如我期望的CPU利用率在多少，负载在多少，GC频率多少之类的指标后，再通过测试不断的调整到一个合理的线程数**

网传的如下是不合理的，Java创建的线程是受很多指标影响的，这么简单的计算肯定是没有严谨的科学依据的，看着就不靠谱，**一定要经过不断的测试**

1. CPU 密集型的程序 - 核心数 + 1
2. I/O 密集型的程序 - 核心数 * 2

## 32. 全局的用户上下文打通你是怎么做的？![](https://img.shields.io/badge/重要-red)

::: details 重要

这个问题还是很关键的,必须掌握

**关于threadlocal**:

`ThreadLocal` 是 Java 提供的一种用于在**多线程环境下存储每个线程自己的变量副本**
的工具。它为每个线程都维护了一个独立的变量副本，这样每个线程都可以独立地改变它的副本，而不会影响其他线程中的副本。
`ThreadLocal` 通常用于解决在多线程环境下共享变量时的并发问题。

1. **基本概念**

`ThreadLocal` 提供了一种线程级别的局部变量存储机制。每个线程都可以通过 `ThreadLocal` 对象来访问该线程独有的变量，即使多个线程在使用同一个
`ThreadLocal` 对象，它们也只能访问自己线程中的值。

主要的几个方法：

- **`set(T value)`**：将当前线程的局部变量设置为 `value`。
- **`get()`**：返回当前线程局部变量的值。
- **`remove()`**：移除当前线程的局部变量，防止内存泄漏。
- **`initialValue()`**：返回当前线程局部变量的初始值。默认是 `null`，但可以通过重写这个方法提供一个默认值。

2. **使用场景**

`ThreadLocal` 主要用于以下场景：

- **线程隔离**：在多线程环境下，每个线程拥有自己独立的变量副本，避免线程之间相互干扰。
- **共享资源管理**：适合在某些情况下需要为每个线程提供独立的资源（如数据库连接、事务、Session、用户信息等）。
- **避免锁**：与传统的通过加锁来保护共享变量不同，`ThreadLocal` 允许每个线程使用自己独立的副本，从而避免了使用同步锁带来的性能开销。

在 Web 应用中，通常会为每个用户请求创建一个独立的用户上下文信息，例如登录用户的身份信息、请求上下文等。这些信息是线程独有的，可以使用
`ThreadLocal` 来保存，避免在每次请求中传递额外的参数。

:::

<img src="https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1707884371208-a9f8d49a-0fe0-477b-afb9-f08db05f5b35.png" alt="img" style="zoom:50%;" />

当用户的请求来临的时候，前端会带着 token，token 里面有用户的 loginId 信息，首先经过网关的全局拦截器，拦截器会帮我们放入
header 里面，传递到其他微服务，微服务自己又实现了拦截器，获取到之后，放入上下文对象中，如果是微服务之间的 feign 调用，则又实现了
feign 的拦截器交互。

## 33. 微服务之间的数据交互是如何做的？

微服务之间的交互用的是 **openfeign** 进行远程调用。回到架构设计上特别设计的 api 模块层，专门来写对外提供的服务 api，打包成
jar 后，需要调用的服务直接引入 jar 包就可以实现调用。api 包，我们定义了当前微服务对外的各种接口，比如我们的题目微服务，想要调用用户信息，直接引入
auth 微服务的 jar 包即可。开启 **feignclient** 指定好应用名，就可以开始调用了。

## 34. 本地缓存在哪里使用的？![](https://img.shields.io/badge/中等-orange)

本地缓存在项目中是在 **分类和标签查询** 使用的，<u>分类和标签的数据很少产生变更，加个缓存速度更快</u>，其实从实际的角度，其实直接用
redis 作为缓存就可以适合这个场景了。但是可以去额外了解 **本地缓存 Guava 的使用**，于是引入了本地缓存。并且基于此配合函数式编程封装了一个公共缓存工具类。

## 35. 你这个函数式编程配合泛型是为了解决什么问题？![](https://img.shields.io/badge/一般-g)

::: tip 提示

这个点我并没有在简历上写,自己暂时知道即可

:::

对于我们大多数的场景，无非就是先查询缓存，缓存内没有数据，则去查询数据库。这个过程其实是一个很固定的模式。

查询数据库的地方可以抽象为函数
function，返回数据和入参可以作为泛型。中间和缓存的交互，我可以通过序列化，在工具内部进行判断。如果做了这个工具类，那就意味着，只要我调用工具类的一个静态方法，传入一个当缓存不存在的时候，我要执行的动作，那么就可以实现缓存的存入和读取了。

## 36. 全文检索怎么做的，有高亮吗？

全文检索只要是引入了 es 模块。依靠其强大的 **倒排索引** 的能力来做关键词的反向搜索，获取搜索结果相关性的评分，评分高的证明相关性越高，排序排在最前面。

高亮是用 **highlight** 的方式，确定高亮数据要展示的标签，比如我们加了一个 `<span> red`，这样返回给前端之后，前端将其展示出来就变为了红色。其中的分词我使用了
ik 分词器，更加的符合中文的切分逻辑。

------

其实 **高亮** 本来就是先找到目标文字, 然后给目标文字 **加上使之高亮的标签**, 然后前端渲染这个带了高亮标签的文档, 这就是高亮

## 37. 你封装的这个 es 工具有什么好处吗？

我们在做 es 的时候，发现无论是 data 操作还是传统的 client 组装起来还是很麻烦的。其中有大量的需要组装的重复代码。

还有集群和索引切换的情况基于这种情况，于是就封装了一个 esclient，其中封装了常见的各种使用，通过入参，传入属性，可以去做不同的查询逻辑，比如高亮，模糊，精准搜索等等。

同时将 es 多集群，多索引的情况，通过加载的形式，放入了工厂 map，涉及不同 service 的场景，直接传入 key 就可以取到 es
的链接。进行切换使用。这个小组件，在项目里面用起来十分的方便。

## 38. 排行榜是如何设计的？

直接看：https://www.yuque.com/jingdianjichi/kwag7a/dkdh73io7gxcbgxe

## 39. 点赞和收藏怎么设计的？

直接看：https://www.yuque.com/jingdianjichi/kwag7a/dkdh73io7gxcbgxe

## 40. 项目有用到定时任务吗？怎么做的？

有的，项目上的定时任务，我们采用的是 **xxljob**
，分布式任务调度，因为我们这一块用的是微服务，必须要考虑多个服务的执行的问题，如果用传统的定时任务方式，防止不了同时执行的问题，可能还有自己写分布式锁来进行排斥处理。不如直接使用
xxljob，xxljob 的调度十分完善，故障转移，负载均衡算法选择都非常方便，引入后，直接配置即可执行。

像项目里面同步点赞和收藏的数据，我们就是采用定时任务来进行操作的。定时任务扫描到待同步的数据，扫描后同步到数据库。

## 41. 你还有什么想要问我的吗？

::: danger 重点

这个问题，鸡哥真的要给你们好好说一说，一定不要说没啥。在这个问题上，到这里就是面试的尾声了，你要体现的是自己的积极上进，意愿强烈，这些东西。说几个比较好的问题。

听🐔鸡哥的准没错

:::

1、面试官，请问咱们这个部门的业务主要是做什么呢？ps：如果是网上能搜到的业务，你就不要在这重复问了，显得你不会收集信息。

2、面试官，请问咱们这个产品的并发和用户量有多少？平时技术挑战多吗？

3、面试官，通过这场面试，您觉得我应该在哪些方面进行继续的努力？

4、面试官，我觉得我十分想加入咱们公司，有哪些东西是我可以提前准备准备的？（ps 这个问题，hr 面，或者终面，觉得效果不错再问）