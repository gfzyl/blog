# MySQL篇(纯享版)

::: warning 为什么会有纯享版

之前的文档设计每一个问题上都有口语话和详细回答两个部分

速刷的时候其实很不想再去看一遍详细的东西, 而只关注于背诵

因此, 纯享版就诞生啦

:::

## 1. MySQL事务的四大特性

MySQL事务有四个特性：原子性、一致性、隔离性和持久性。原子性保证事务中的操作要么全做要么全不做，比如银行转账，扣款和加款必须同时成功或同时失败；一致性确保事务执行前后，数据库从一个一致状态到另一个一致状态，比如转账后账户A减少的金额等于账户B增加的金额；隔离性保证并发事务互不干扰，有不同隔离级别来避免脏读、不可重复读等问题；持久性则确保事务提交后的数据不会丢失，即使系统崩溃，数据仍然存在。

## 2. MySQL的事务隔离级别

MySQL支持四种事务隔离级别：读未提交、读已提交、可重复读和串行化。读未提交允许事务读取未提交的数据，可能导致脏读；读已提交只能读取已提交的数据，避免脏读，但可能出现不可重复读；可重复读保证在同一个事务中多次读取数据结果一致，避免脏读和不可重复读，但可能出现幻读；串行化是最高级别，事务串行执行，完全避免脏读、不可重复读和幻读，但会影响并发性能。

## 3. MySQL脏读,幻读,不可重复读如何解释

脏读就是一个事务读取了另一个未提交事务的数据，之后如果该事务回滚，那么读取的数据就是无效的。不可重复读是指一个事务在多次读取同一数据时，由于另一个事务的修改，导致数据前后不一致。而幻读则是指事务在读取数据时，另一事务插入了新数据，导致读取的记录数量发生了变化。不可重复读主要是数据修改的问题，而幻读是新增或删除数据导致的记录变化。

## 4. MySQL存储引擎MyISAM和InnoDB区别

MyISAM 和 InnoDB 是 MySQL 中两种常见的存储引擎。MyISAM 不支持事务和外键，锁机制是表级锁，适合读多写少的场景，比如日志分析。而 InnoDB 支持事务和外键，采用行级锁，适合高并发的事务密集型场景，比如在线交易系统。此外，MyISAM 全文索引支持更好，数据存储效率较高，但崩溃恢复能力弱；InnoDB 虽然占用更多存储空间，但崩溃恢复能力强，适合处理大规模数据。

## 5. 存储引擎应该如何选择

选择 MySQL 存储引擎时，要根据应用需求来做选择。如果需要支持事务，InnoDB 是更好的选择，它支持 ACID 特性，适合高并发、频繁写操作的场景，同时还支持外键约束，能保证数据一致性。MyISAM 则不支持事务，但在读多写少的场景中表现优秀，查询速度快，占用资源少。另外，MyISAM 原生支持全文索引，适合需要全文搜索的应用，而 InnoDB 从 MySQL 5.6 开始也支持，但性能可能不如 MyISAM。在数据恢复方面，InnoDB 支持自动崩溃恢复，数据安全性较高，MyISAM 恢复相对较慢。此外，InnoDB 的表大小上限为 64TB，而 MyISAM 可以支持到 256TB。根据需求选择合适的存储引擎，可以获得最佳性能和数据完整性保障。

## 6. 自适应Hash索引有什么坏处

自适应哈希索引是 InnoDB 的优化功能，用来加速一些频繁访问的查询。但它有一些缺点。首先，它需要额外的内存，如果哈希表太大，会占用很多内存资源。其次，频繁写入时，维护哈希索引会增加 CPU 的负担。此外，在高并发环境中，更新哈希索引时可能会引发锁竞争，影响性能。这个索引对等值查询效果好，但对范围查询（比如 `>` 或 `BETWEEN`）帮助不大。最后，虽然它是自动管理的，但有时需要调整配置，这会增加数据库管理的复杂性。

## 7. MySQL使用规范有哪些

选择存储引擎时要根据应用场景来决定，比如 InnoDB 适合事务处理，而 MyISAM 适合读多写少的场景。选择字符集时，要确保它能支持所需的语言，比如使用 `utf8mb4`。SQL 语句一定要加注释，以提高可读性。尽量避免使用存储过程、视图、触发器和事件，因为它们会增加复杂性。文本字段最好不要和主表放在一起使用，以免影响性能。外键的使用要谨慎，尽量避免。要遵循命名规范，确保一致性。使用域名连接数据库会更方便管理。单表的列数要控制，避免大宽表。最后，设计数据库时要结合实际业务需求，确保结构合理。

## 8. 在建立索引的时候,需要考虑哪些因素

在建立索引时，要考虑以下几点：首先，了解你的查询模式，关注哪些查询最常用，并确保索引能覆盖这些查询，减少回表操作。其次，考虑数据分布，高选择性的列更适合索引，而低选择性的列通常不适合。然后，根据索引的类型选择合适的方案，比如 B-Tree 索引适合大多数查询，全文索引用于文本搜索。还要注意索引的覆盖范围，单列索引和复合索引各有优缺点，要根据实际需求选择。此外，要考虑索引的维护成本，比如写操作会增加开销和存储空间占用。表的大小也影响索引的设计，大表通常需要更精细的索引。定期评估和优化现有索引，并监控索引的使用情况。最后，索引列的顺序很重要，复合索引要遵循最左前缀原则，根据查询需求调整索引范围和条件。

## 9. 数据库的三范式是什

数据库的三范式包括第一范式、第二范式和第三范式。第一范式要求数据表中的每个列都包含原子值，第二范式要求每个非主键列都完全依赖于主键，第三范式则要求所有非主键列都与主键直接相关。简单来说，这些范式帮助数据库设计保持数据的整洁和一致性。

## 10. MySQL的explain有哪些列

MySQL的`EXPLAIN`可以帮助你了解查询的执行计划。它主要有以下几列：`id`、`select_type`、`table`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`Extra`。这些列告诉你每个表的扫描方式、使用的索引、预期的结果行数等信息，有助于优化查询性能。

## 11. 用explain分析举一个具体的例子

使用 `EXPLAIN` 可以帮你了解查询是怎么执行的。比如，有一个简单的查询：`SELECT * FROM employees WHERE department = 'Sales';`。用 `EXPLAIN` 分析这个查询，你可以看到列出如 `id`、`select_type`、`table`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows` 和 `Extra` 等信息。这些信息告诉你查询用到了哪些索引，预计扫描了多少行，查询的效率如何等，从而帮助你优化数据库性能。

## 12. MySQL语句有哪些种类

数据库中有几种不同的语言来处理不同的任务：

1. **数据定义语言 (DDL)** 用于创建和管理数据库结构，比如创建表和索引。例如，你可以用 `CREATE` 语句创建一个表，`ALTER` 语句修改表结构，`DROP` 语句删除表，`TRUNCATE` 清空表数据但保留结构。
2. **数据操作语言 (DML)** 用于处理表中的数据，比如插入、更新、删除和查询数据。比如，`INSERT` 用来添加数据，`UPDATE` 用来更新数据，`DELETE` 用来删除数据，而 `SELECT` 用来查询数据。
3. **数据控制语言 (DCL)** 用于控制用户访问权限，比如 `GRANT` 授予权限，`REVOKE` 撤销权限。
4. **事务控制语言 (TCL)** 用于管理事务，确保数据的一致性。例如，`START TRANSACTION` 开始事务，`COMMIT` 提交事务，`ROLLBACK` 回滚事务，还有 `SAVEPOINT` 和 `ROLLBACK TO SAVEPOINT` 用来设置和回滚到事务中的保存点。
5. **数据查询语言 (DQL)** 主要是 `SELECT` 语句，用于查询数据。
6. **其他**：例如，`EXPLAIN` 解释查询执行计划，`SHOW` 显示数据库对象的信息，`DESCRIBE` 显示表结构。

## 13. MySQL查询优化建议

在优化查询时，首先要避免全表扫描，最好在查询涉及的字段上建立索引，这样能显著提高查询速度。其次，尽量不要在 WHERE 子句中判断 NULL 值，创建表时就设置好字段为 NOT NULL 或使用特殊值代替。避免使用 `!=` 或 `<>` 操作符，因为这些操作符会降低索引的利用率，尽量用 `<`、`<=`、`=`、`>`、`>=`、`BETWEEN` 或 `IN`。同时，使用 OR 连接的条件也会导致全表扫描，考虑用 UNION 合并查询。对于 IN 和 NOT IN，特别是当值是连续的，可以用 BETWEEN 替代，这样会更高效。LIKE 查询也要注意，避免用 `%abc%` 或 `%abc`，这会导致全表扫描，如果可能的话用全文检索，只有以 `abc%` 开头的 LIKE 查询才可能利用索引。对于参数化查询，避免在 WHERE 子句中使用参数，尽量强制使用索引来提高查询效率。此外，避免在 WHERE 子句中对字段进行表达式操作，这会导致全表扫描。最后，使用 EXISTS 替代 IN 可以提升查询效率，因为 EXISTS 会在找到结果后立即停止查询，而 IN 需要扫描整个子查询结果集。

## 14. MySQL聚集索引是什么

在 MySQL 中，聚集索引是将数据表的记录按索引的顺序物理存储的方式。这意味着表里的数据行和索引行是一起存储的，数据的顺序和索引的顺序是一致的。聚集索引的叶节点包含了实际的数据行，所以它的优点是查询效率高，特别是对范围查询和排序操作更有利。不过，它也有一些缺点，比如插入数据时可能比较慢，因为要维持索引顺序，还可能导致更新代价高和存储空间占用多。在 InnoDB 存储引擎中，如果你没有显式地定义主键，它会自动选择一个唯一的非空索引作为聚集索引。如果没有这样的索引，它还会自动生成一个隐藏的聚集索引。选择聚集索引时，最好选择那些常用来查询、排序的列，同时避免频繁更新的列，以减少维护成本。

## 15. 为什么聚集索引不要选择频繁的更新的列

聚集索引不要选择频繁更新的列，主要是因为更新这些列会引发一系列性能问题。首先，数据需要重排来保持索引的顺序，这样会消耗大量资源。其次，更新会导致页分裂，增加了磁盘碎片和查询延迟。此外，频繁更新还会影响二级索引，因为它们也需要同步更新。最后，这些操作可能增加锁争用和死锁的风险，从而影响系统的整体性能。因此，选择聚集索引时，应尽量避免使用那些更新频繁的列。

## 16. MySQL非聚集索引是什么

非聚集索引（也叫做辅助索引或二级索引）与聚集索引不同，它不会改变数据的物理存储顺序。相反，非聚集索引的叶节点只包含指向实际数据行的指针，这些指针通常是聚集索引的键。一个表可以有多个非聚集索引，这样可以加速对不同列的查询。不过，非聚集索引会占用额外的存储空间，并且在数据插入、更新或删除时需要维护，可能会增加一些额外的开销。

## 17. MySQL回表查询是什么

回表查询是指在使用非聚集索引时，数据库需要先通过索引找到相关记录的主键，然后再根据这个主键去实际的数据表中查找具体的数据。这种操作发生在你查询的列不完全包含在索引中时。举个例子，如果你在一个表的某列上创建了非聚集索引，然后查询其他列的数据，数据库就需要先通过索引找到主键，再去表中获取这些列的数据。为了减少这种操作，可以使用覆盖索引，即索引中包含了所有查询需要的列，这样可以直接从索引中获取数据，不需要回表查询。

## 18. MySQL的覆盖索引是什么

在 MySQL 中，覆盖索引就是一个索引包含了查询需要的所有列，这样查询就能完全从这个索引中获取数据，而不用再访问实际的数据行。这可以显著提高查询速度，因为减少了对数据的访问次数，从而减少了磁盘 I/O 操作。如果你创建了一个覆盖索引，那么 MySQL 就能直接从索引里找到所有需要的数据，避免了回表的步骤，这对提高查询性能非常有效。但是，要注意覆盖索引可能会增加索引的大小，并且在插入、更新和删除数据时会带来额外的维护开销。

## 19. MySQL的索引结构?

在 MySQL 中，主要有两种索引结构：B+树索引和哈希索引。B+树索引是最常用的，尤其在 InnoDB 存储引擎中使用。它是一种平衡树，数据存储在叶子节点，支持范围查询和顺序访问。哈希索引则主要用于等值查询，速度很快，但不支持范围查询。InnoDB 使用 B+树来实现聚簇索引（按主键顺序存储数据）和辅助索引（存储主键指针）。哈希索引在 Memory 存储引擎中用得比较多。

## 20. 什么是前缀索引

前缀索引是一种只对字符串列的前几位进行索引的方式。它特别适用于字符串长度较长的列，当前几位就能有效区分记录时，可以显著减少索引的存储空间，提高查询性能。创建时需要指定前缀长度，比如对一个 URL 列的前 10 个字符进行索引。虽然前缀索引能减少存储需求，但可能不够精确，特别是当前缀相同时可能需要额外扫描。

## 21. 什么情况下应不建或者少建索引?

在以下情况下，你可能不需要或应少建索引：1) 表数据量小，扫描整个表可能更快；2) 表的写操作频繁，索引维护成本高；3) 索引列的基数低（如性别），索引效果不佳；4) 频繁批量数据加载，索引维护增加开销；5) 临时表或短生命周期表，创建索引成本高；6) 查询模式不稳定，创建索引效果不确定。总之，索引应该根据实际需求和数据特征来决定。

## 22. MySQL常见索引失效的情况?

在 MySQL 中，索引可能会失效，导致查询变慢。一些常见的情况包括在索引列上使用函数或表达式、数据类型不匹配导致隐式类型转换、使用 `OR` 条件时、前导模糊查询时、使用不等于操作符时、使用 `IS NULL` 或 `IS NOT NULL`、在复合索引中先用范围条件后再用等值条件、不满足最左前缀原则、负向查询以及数据分布不均匀。了解这些情况有助于优化你的查询性能。

## 23. 唯一索引比普通索引快吗?

唯一索引和普通索引在查询上的表现差不多，因为它们都用相似的方式来快速找到数据。但在插入和更新时，唯一索引会多一步检查，以确保新数据不会和已有的数据重复，这样会稍微慢一点。普通索引不需要这个检查，所以插入和更新会更快。删除数据对这两种索引的影响差不多，因为删除只是从索引中移除数据而已。

## 24. A,B,C三个字段组成联合索引, AB \ AC \ BC 三种情况下查询是否能命中索引?

对于一个联合索引(A, B, C)，查询是否能利用索引取决于查询条件是怎么写的。

1. 如果查询条件是 (A, B)，这个条件是从最左边开始的，所以能命中索引。
2. 如果查询条件是 (A, C)，虽然 A 能用索引，但因为跳过了 B，所以 C 的部分就不能用索引了，只能部分命中。
3. 如果查询条件是 (B, C)，这个查询没有从最左边的 A 开始，所以不能利用这个联合索引。
4. 如果查询条件只有 A，那也能命中索引，因为 A 是最左边的字段。
5. 如果查询条件只有 B，同样不能命中索引，因为它没有从最左边的 A 开始。
6. 如果查询条件是 (A, B, C)，这个条件包含了所有的字段，所以能完全利用索引。

## 25. B+树索引和哈希索引的区别?

B+树索引和哈希索引是数据库中两种常见的索引类型，它们在结构、适用场景和性能上有很大的不同。

**B+树索引**就像一个排序好的树。它把数据存储在树的叶子节点上，内部节点只是存储了键值和指向其他节点的指针。B+树的特点是它的数据是有序的，这让它在做范围查询（比如查找某个范围内的数据）时特别有用。它支持等值查询和范围查询，并且在插入和删除时会自动调整保持平衡。这种索引也比较“磁盘友好”，因为它的结构通常和磁盘页的大小匹配，所以减少了磁盘的读写操作。用B+树索引的场景包括需要频繁做范围查询、排序操作或者涉及多个字段的查询。

**哈希索引**则是基于哈希表的。它通过一个哈希函数把键值转换成哈希表中的位置，每个位置上存储了指向实际数据的指针。哈希索引的特点是数据是无序的，不适合做范围查询，但在做等值查询（比如查找具体的某个值）时效率非常高，查询速度几乎是瞬时的。哈希索引主要适合频繁的等值查询，不适合范围查询和排序操作。它通常存储在内存中，这样可以更快地访问数据。

## 26. 哈希索引的优势及不适用的场景?

哈希索引有几个明显的优点。首先，它处理等值查询（像 `=` 或 `IN`）非常快，因为哈希函数直接将数据映射到特定位置，使查找时间几乎是瞬时的。其次，插入和删除操作简单，不需要维护平衡，只需计算哈希值就能完成。哈希索引通常存储在内存中，访问速度快，非常适合需要快速访问数据的场景。设计得当的哈希函数可以减少冲突，提高效率。

不过，哈希索引也有一些不足之处。它不支持范围查询，比如 `BETWEEN` 或 `>`，因为数据在哈希表中无序，也无法处理排序操作。部分匹配查询（如 `LIKE 'abc%'`）也不适合使用哈希索引，因为无法进行前缀或模糊匹配。此外，哈希索引不适合多字段的组合查询，主要适用于单字段查询。处理哈希冲突也可能带来额外开销，而哈希表通常需要较大的内存，如果内存不足，可能会影响性能。

## 27. B树 和 B+树的区别?

B树和B+树是两种常见的索引结构，各有优缺点。B树的每个节点既存储数据也存储索引信息，这使得它在范围查询时效率较低，因为数据分散在多个节点中，需要遍历多个节点来获取完整的数据。B树的内节点和叶节点结构复杂，叶节点不一定在同一层，导致树的高度可能不均匀。

相比之下，B+树将所有实际数据存储在叶节点中，内节点只存储索引键和指针，这样使得结构更简单。叶节点通过链表相连，这使得范围查询和顺序访问变得非常高效。B+树的叶节点都在同一层，树的高度均匀，内存使用也更加集中。

总的来说，B树适合需要频繁插入和删除操作的场景，因为它在节点上直接进行操作，而B+树则适合需要高效范围查询和顺序访问的场景，由于其叶节点的链表结构，使得这些操作更为高效。

## 28. 为什么说 B+树 比 B树更适合实际应用中作为数据库索引?

B树和B+树在许多方面都存在差异。B树的每个节点都存储数据，因此在进行范围查询时需要遍历多个节点，效率较低。相对来说，B+树将所有数据存储在叶节点中，并通过链表将这些叶节点连接起来，这使得范围查询时只需遍历链表，查询效率更高。B树的数据分布在所有节点中，导致内存使用较为分散，并且需要更多的磁盘I/O操作。相比之下，B+树的内节点只存储索引数据，实际数据集中在叶节点上，这样可以更高效地利用内存，减少磁盘I/O操作。此外，B树的叶节点可能不在同一层，导致树的高度不均匀，影响查询速度。而B+树的所有叶节点都在同一层，使得树的高度更均匀，查询速度更快。插入和删除操作方面，B树可能会影响整个树的平衡，操作较复杂；而B+树的操作主要集中在叶节点，对内节点影响较小，维护起来更简单。最后，B树由于数据存储在所有节点中，空间利用率较低，而B+树的内节点只存储索引，空间利用率更高，整体结构也更简单，因此B+树在实现和维护上更为方便。