# MySQL篇(纯享版)

::: warning 为什么会有纯享版

之前的文档设计每一个问题上都有口语话和详细回答两个部分

速刷的时候其实很不想再去看一遍详细的东西, 而只关注于背诵

因此, 纯享版就诞生啦

:::



------

以下为MySQL上篇内容

## 1. MySQL事务的四大特性

MySQL事务有四个特性：原子性、一致性、隔离性和持久性。原子性保证事务中的操作要么全做要么全不做，比如银行转账，扣款和加款必须同时成功或同时失败；一致性确保事务执行前后，数据库从一个一致状态到另一个一致状态，比如转账后账户A减少的金额等于账户B增加的金额；隔离性保证并发事务互不干扰，有不同隔离级别来避免脏读、不可重复读等问题；持久性则确保事务提交后的数据不会丢失，即使系统崩溃，数据仍然存在。

## 2. MySQL的事务隔离级别

MySQL支持四种事务隔离级别：读未提交、读已提交、可重复读和串行化。读未提交允许事务读取未提交的数据，可能导致脏读；读已提交只能读取已提交的数据，避免脏读，但可能出现不可重复读；可重复读保证在同一个事务中多次读取数据结果一致，避免脏读和不可重复读，但可能出现幻读；串行化是最高级别，事务串行执行，完全避免脏读、不可重复读和幻读，但会影响并发性能。

## 3. MySQL脏读,幻读,不可重复读如何解释

脏读就是一个事务读取了另一个未提交事务的数据，之后如果该事务回滚，那么读取的数据就是无效的。不可重复读是指一个事务在多次读取同一数据时，由于另一个事务的修改，导致数据前后不一致。而幻读则是指事务在读取数据时，另一事务插入了新数据，导致读取的记录数量发生了变化。不可重复读主要是数据修改的问题，而幻读是新增或删除数据导致的记录变化。

## 4. MySQL存储引擎MyISAM和InnoDB区别

MyISAM 和 InnoDB 是 MySQL 中两种常见的存储引擎。MyISAM 不支持事务和外键，锁机制是表级锁，适合读多写少的场景，比如日志分析。而 InnoDB 支持事务和外键，采用行级锁，适合高并发的事务密集型场景，比如在线交易系统。此外，MyISAM 全文索引支持更好，数据存储效率较高，但崩溃恢复能力弱；InnoDB 虽然占用更多存储空间，但崩溃恢复能力强，适合处理大规模数据。

## 5. 存储引擎应该如何选择

选择 MySQL 存储引擎时，要根据应用需求来做选择。如果需要支持事务，InnoDB 是更好的选择，它支持 ACID 特性，适合高并发、频繁写操作的场景，同时还支持外键约束，能保证数据一致性。MyISAM 则不支持事务，但在读多写少的场景中表现优秀，查询速度快，占用资源少。另外，MyISAM 原生支持全文索引，适合需要全文搜索的应用，而 InnoDB 从 MySQL 5.6 开始也支持，但性能可能不如 MyISAM。在数据恢复方面，InnoDB 支持自动崩溃恢复，数据安全性较高，MyISAM 恢复相对较慢。此外，InnoDB 的表大小上限为 64TB，而 MyISAM 可以支持到 256TB。根据需求选择合适的存储引擎，可以获得最佳性能和数据完整性保障。

## 6. 自适应Hash索引有什么坏处

自适应哈希索引是 InnoDB 的优化功能，用来加速一些频繁访问的查询。但它有一些缺点。首先，它需要额外的内存，如果哈希表太大，会占用很多内存资源。其次，频繁写入时，维护哈希索引会增加 CPU 的负担。此外，在高并发环境中，更新哈希索引时可能会引发锁竞争，影响性能。这个索引对等值查询效果好，但对范围查询（比如 `>` 或 `BETWEEN`）帮助不大。最后，虽然它是自动管理的，但有时需要调整配置，这会增加数据库管理的复杂性。

## 7. MySQL使用规范有哪些

选择存储引擎时要根据应用场景来决定，比如 InnoDB 适合事务处理，而 MyISAM 适合读多写少的场景。选择字符集时，要确保它能支持所需的语言，比如使用 `utf8mb4`。SQL 语句一定要加注释，以提高可读性。尽量避免使用存储过程、视图、触发器和事件，因为它们会增加复杂性。文本字段最好不要和主表放在一起使用，以免影响性能。外键的使用要谨慎，尽量避免。要遵循命名规范，确保一致性。使用域名连接数据库会更方便管理。单表的列数要控制，避免大宽表。最后，设计数据库时要结合实际业务需求，确保结构合理。

## 8. 在建立索引的时候,需要考虑哪些因素

在建立索引时，要考虑以下几点：首先，了解你的查询模式，关注哪些查询最常用，并确保索引能覆盖这些查询，减少回表操作。其次，考虑数据分布，高选择性的列更适合索引，而低选择性的列通常不适合。然后，根据索引的类型选择合适的方案，比如 B-Tree 索引适合大多数查询，全文索引用于文本搜索。还要注意索引的覆盖范围，单列索引和复合索引各有优缺点，要根据实际需求选择。此外，要考虑索引的维护成本，比如写操作会增加开销和存储空间占用。表的大小也影响索引的设计，大表通常需要更精细的索引。定期评估和优化现有索引，并监控索引的使用情况。最后，索引列的顺序很重要，复合索引要遵循最左前缀原则，根据查询需求调整索引范围和条件。

## 9. 数据库的三范式是什

数据库的三范式包括第一范式、第二范式和第三范式。第一范式要求数据表中的每个列都包含原子值，第二范式要求每个非主键列都完全依赖于主键，第三范式则要求所有非主键列都与主键直接相关。简单来说，这些范式帮助数据库设计保持数据的整洁和一致性。

## 10. MySQL的explain有哪些列

MySQL的`EXPLAIN`可以帮助你了解查询的执行计划。它主要有以下几列：`id`、`select_type`、`table`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`Extra`。这些列告诉你每个表的扫描方式、使用的索引、预期的结果行数等信息，有助于优化查询性能。

## 11. 用explain分析举一个具体的例子

使用 `EXPLAIN` 可以帮你了解查询是怎么执行的。比如，有一个简单的查询：`SELECT * FROM employees WHERE department = 'Sales';`。用 `EXPLAIN` 分析这个查询，你可以看到列出如 `id`、`select_type`、`table`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows` 和 `Extra` 等信息。这些信息告诉你查询用到了哪些索引，预计扫描了多少行，查询的效率如何等，从而帮助你优化数据库性能。

## 12. MySQL语句有哪些种类

数据库中有几种不同的语言来处理不同的任务：

1. **数据定义语言 (DDL)** 用于创建和管理数据库结构，比如创建表和索引。例如，你可以用 `CREATE` 语句创建一个表，`ALTER` 语句修改表结构，`DROP` 语句删除表，`TRUNCATE` 清空表数据但保留结构。
2. **数据操作语言 (DML)** 用于处理表中的数据，比如插入、更新、删除和查询数据。比如，`INSERT` 用来添加数据，`UPDATE` 用来更新数据，`DELETE` 用来删除数据，而 `SELECT` 用来查询数据。
3. **数据控制语言 (DCL)** 用于控制用户访问权限，比如 `GRANT` 授予权限，`REVOKE` 撤销权限。
4. **事务控制语言 (TCL)** 用于管理事务，确保数据的一致性。例如，`START TRANSACTION` 开始事务，`COMMIT` 提交事务，`ROLLBACK` 回滚事务，还有 `SAVEPOINT` 和 `ROLLBACK TO SAVEPOINT` 用来设置和回滚到事务中的保存点。
5. **数据查询语言 (DQL)** 主要是 `SELECT` 语句，用于查询数据。
6. **其他**：例如，`EXPLAIN` 解释查询执行计划，`SHOW` 显示数据库对象的信息，`DESCRIBE` 显示表结构。

## 13. MySQL查询优化建议

在优化查询时，首先要避免全表扫描，最好在查询涉及的字段上建立索引，这样能显著提高查询速度。其次，尽量不要在 WHERE 子句中判断 NULL 值，创建表时就设置好字段为 NOT NULL 或使用特殊值代替。避免使用 `!=` 或 `<>` 操作符，因为这些操作符会降低索引的利用率，尽量用 `<`、`<=`、`=`、`>`、`>=`、`BETWEEN` 或 `IN`。同时，使用 OR 连接的条件也会导致全表扫描，考虑用 UNION 合并查询。对于 IN 和 NOT IN，特别是当值是连续的，可以用 BETWEEN 替代，这样会更高效。LIKE 查询也要注意，避免用 `%abc%` 或 `%abc`，这会导致全表扫描，如果可能的话用全文检索，只有以 `abc%` 开头的 LIKE 查询才可能利用索引。对于参数化查询，避免在 WHERE 子句中使用参数，尽量强制使用索引来提高查询效率。此外，避免在 WHERE 子句中对字段进行表达式操作，这会导致全表扫描。最后，使用 EXISTS 替代 IN 可以提升查询效率，因为 EXISTS 会在找到结果后立即停止查询，而 IN 需要扫描整个子查询结果集。

## 14. MySQL聚集索引是什么

在 MySQL 中，聚集索引是将数据表的记录按索引的顺序物理存储的方式。这意味着表里的数据行和索引行是一起存储的，数据的顺序和索引的顺序是一致的。聚集索引的叶节点包含了实际的数据行，所以它的优点是查询效率高，特别是对范围查询和排序操作更有利。不过，它也有一些缺点，比如插入数据时可能比较慢，因为要维持索引顺序，还可能导致更新代价高和存储空间占用多。在 InnoDB 存储引擎中，如果你没有显式地定义主键，它会自动选择一个唯一的非空索引作为聚集索引。如果没有这样的索引，它还会自动生成一个隐藏的聚集索引。选择聚集索引时，最好选择那些常用来查询、排序的列，同时避免频繁更新的列，以减少维护成本。

## 15. 为什么聚集索引不要选择频繁的更新的列

聚集索引不要选择频繁更新的列，主要是因为更新这些列会引发一系列性能问题。首先，数据需要重排来保持索引的顺序，这样会消耗大量资源。其次，更新会导致页分裂，增加了磁盘碎片和查询延迟。此外，频繁更新还会影响二级索引，因为它们也需要同步更新。最后，这些操作可能增加锁争用和死锁的风险，从而影响系统的整体性能。因此，选择聚集索引时，应尽量避免使用那些更新频繁的列。

## 16. MySQL非聚集索引是什么

非聚集索引（也叫做辅助索引或二级索引）与聚集索引不同，它不会改变数据的物理存储顺序。相反，非聚集索引的叶节点只包含指向实际数据行的指针，这些指针通常是聚集索引的键。一个表可以有多个非聚集索引，这样可以加速对不同列的查询。不过，非聚集索引会占用额外的存储空间，并且在数据插入、更新或删除时需要维护，可能会增加一些额外的开销。

## 17. MySQL回表查询是什么

回表查询是指在使用非聚集索引时，数据库需要先通过索引找到相关记录的主键，然后再根据这个主键去实际的数据表中查找具体的数据。这种操作发生在你查询的列不完全包含在索引中时。举个例子，如果你在一个表的某列上创建了非聚集索引，然后查询其他列的数据，数据库就需要先通过索引找到主键，再去表中获取这些列的数据。为了减少这种操作，可以使用覆盖索引，即索引中包含了所有查询需要的列，这样可以直接从索引中获取数据，不需要回表查询。

## 18. MySQL的覆盖索引是什么

在 MySQL 中，覆盖索引就是一个索引包含了查询需要的所有列，这样查询就能完全从这个索引中获取数据，而不用再访问实际的数据行。这可以显著提高查询速度，因为减少了对数据的访问次数，从而减少了磁盘 I/O 操作。如果你创建了一个覆盖索引，那么 MySQL 就能直接从索引里找到所有需要的数据，避免了回表的步骤，这对提高查询性能非常有效。但是，要注意覆盖索引可能会增加索引的大小，并且在插入、更新和删除数据时会带来额外的维护开销。

## 19. MySQL的索引结构?

在 MySQL 中，主要有两种索引结构：B+树索引和哈希索引。B+树索引是最常用的，尤其在 InnoDB 存储引擎中使用。它是一种平衡树，数据存储在叶子节点，支持范围查询和顺序访问。哈希索引则主要用于等值查询，速度很快，但不支持范围查询。InnoDB 使用 B+树来实现聚簇索引（按主键顺序存储数据）和辅助索引（存储主键指针）。哈希索引在 Memory 存储引擎中用得比较多。

## 20. 什么是前缀索引

前缀索引是一种只对字符串列的前几位进行索引的方式。它特别适用于字符串长度较长的列，当前几位就能有效区分记录时，可以显著减少索引的存储空间，提高查询性能。创建时需要指定前缀长度，比如对一个 URL 列的前 10 个字符进行索引。虽然前缀索引能减少存储需求，但可能不够精确，特别是当前缀相同时可能需要额外扫描。

## 21. 什么情况下应不建或者少建索引?

在以下情况下，你可能不需要或应少建索引：1) 表数据量小，扫描整个表可能更快；2) 表的写操作频繁，索引维护成本高；3) 索引列的基数低（如性别），索引效果不佳；4) 频繁批量数据加载，索引维护增加开销；5) 临时表或短生命周期表，创建索引成本高；6) 查询模式不稳定，创建索引效果不确定。总之，索引应该根据实际需求和数据特征来决定。

## 22. MySQL常见索引失效的情况?

在 MySQL 中，索引可能会失效，导致查询变慢。一些常见的情况包括在索引列上使用函数或表达式、数据类型不匹配导致隐式类型转换、使用 `OR` 条件时、前导模糊查询时、使用不等于操作符时、使用 `IS NULL` 或 `IS NOT NULL`、在复合索引中先用范围条件后再用等值条件、不满足最左前缀原则、负向查询以及数据分布不均匀。了解这些情况有助于优化你的查询性能。

## 23. 唯一索引比普通索引快吗?

唯一索引和普通索引在查询上的表现差不多，因为它们都用相似的方式来快速找到数据。但在插入和更新时，唯一索引会多一步检查，以确保新数据不会和已有的数据重复，这样会稍微慢一点。普通索引不需要这个检查，所以插入和更新会更快。删除数据对这两种索引的影响差不多，因为删除只是从索引中移除数据而已。

## 24. A,B,C三个字段组成联合索引, AB \ AC \ BC 三种情况下查询是否能命中索引?

对于一个联合索引(A, B, C)，查询是否能利用索引取决于查询条件是怎么写的。

1. 如果查询条件是 (A, B)，这个条件是从最左边开始的，所以能命中索引。
2. 如果查询条件是 (A, C)，虽然 A 能用索引，但因为跳过了 B，所以 C 的部分就不能用索引了，只能部分命中。
3. 如果查询条件是 (B, C)，这个查询没有从最左边的 A 开始，所以不能利用这个联合索引。
4. 如果查询条件只有 A，那也能命中索引，因为 A 是最左边的字段。
5. 如果查询条件只有 B，同样不能命中索引，因为它没有从最左边的 A 开始。
6. 如果查询条件是 (A, B, C)，这个条件包含了所有的字段，所以能完全利用索引。

## 25. B+树索引和哈希索引的区别?

B+树索引和哈希索引是数据库中两种常见的索引类型，它们在结构、适用场景和性能上有很大的不同。

**B+树索引**就像一个排序好的树。它把数据存储在树的叶子节点上，内部节点只是存储了键值和指向其他节点的指针。B+树的特点是它的数据是有序的，这让它在做范围查询（比如查找某个范围内的数据）时特别有用。它支持等值查询和范围查询，并且在插入和删除时会自动调整保持平衡。这种索引也比较“磁盘友好”，因为它的结构通常和磁盘页的大小匹配，所以减少了磁盘的读写操作。用B+树索引的场景包括需要频繁做范围查询、排序操作或者涉及多个字段的查询。

**哈希索引**则是基于哈希表的。它通过一个哈希函数把键值转换成哈希表中的位置，每个位置上存储了指向实际数据的指针。哈希索引的特点是数据是无序的，不适合做范围查询，但在做等值查询（比如查找具体的某个值）时效率非常高，查询速度几乎是瞬时的。哈希索引主要适合频繁的等值查询，不适合范围查询和排序操作。它通常存储在内存中，这样可以更快地访问数据。

## 26. 哈希索引的优势及不适用的场景?

哈希索引有几个明显的优点。首先，它处理等值查询（像 `=` 或 `IN`）非常快，因为哈希函数直接将数据映射到特定位置，使查找时间几乎是瞬时的。其次，插入和删除操作简单，不需要维护平衡，只需计算哈希值就能完成。哈希索引通常存储在内存中，访问速度快，非常适合需要快速访问数据的场景。设计得当的哈希函数可以减少冲突，提高效率。

不过，哈希索引也有一些不足之处。它不支持范围查询，比如 `BETWEEN` 或 `>`，因为数据在哈希表中无序，也无法处理排序操作。部分匹配查询（如 `LIKE 'abc%'`）也不适合使用哈希索引，因为无法进行前缀或模糊匹配。此外，哈希索引不适合多字段的组合查询，主要适用于单字段查询。处理哈希冲突也可能带来额外开销，而哈希表通常需要较大的内存，如果内存不足，可能会影响性能。

## 27. B树 和 B+树的区别?

B树和B+树是两种常见的索引结构，各有优缺点。B树的每个节点既存储数据也存储索引信息，这使得它在范围查询时效率较低，因为数据分散在多个节点中，需要遍历多个节点来获取完整的数据。B树的内节点和叶节点结构复杂，叶节点不一定在同一层，导致树的高度可能不均匀。

相比之下，B+树将所有实际数据存储在叶节点中，内节点只存储索引键和指针，这样使得结构更简单。叶节点通过链表相连，这使得范围查询和顺序访问变得非常高效。B+树的叶节点都在同一层，树的高度均匀，内存使用也更加集中。

总的来说，B树适合需要频繁插入和删除操作的场景，因为它在节点上直接进行操作，而B+树则适合需要高效范围查询和顺序访问的场景，由于其叶节点的链表结构，使得这些操作更为高效。

## 28. 为什么说 B+树 比 B树更适合实际应用中作为数据库索引?

B树和B+树在许多方面都存在差异。B树的每个节点都存储数据，因此在进行范围查询时需要遍历多个节点，效率较低。相对来说，B+树将所有数据存储在叶节点中，并通过链表将这些叶节点连接起来，这使得范围查询时只需遍历链表，查询效率更高。B树的数据分布在所有节点中，导致内存使用较为分散，并且需要更多的磁盘I/O操作。相比之下，B+树的内节点只存储索引数据，实际数据集中在叶节点上，这样可以更高效地利用内存，减少磁盘I/O操作。此外，B树的叶节点可能不在同一层，导致树的高度不均匀，影响查询速度。而B+树的所有叶节点都在同一层，使得树的高度更均匀，查询速度更快。插入和删除操作方面，B树可能会影响整个树的平衡，操作较复杂；而B+树的操作主要集中在叶节点，对内节点影响较小，维护起来更简单。最后，B树由于数据存储在所有节点中，空间利用率较低，而B+树的内节点只存储索引，空间利用率更高，整体结构也更简单，因此B+树在实现和维护上更为方便。



------

以下为MySQL下篇内容

## 1. MySQL如何做分库分表

### 口语化回答

MySQL 分库分表是为了应对数据量过大导致的性能问题。垂直分表是将一个大表按字段拆分，适合不同业务的数据独立存储，查询性能有所提升。水平分表则是按数据的某个字段值分片，把数据分散到多个表中，能解决大数据量问题。为了进一步提升性能，还可以同时进行分库和分表，将数据分散到多个库和表里。这些方法可以提升系统处理能力，但也增加了跨表查询和数据路由的复杂性。

## 2. MySQL主从同步原理

### 口语化回答

MySQL主从同步是一种数据复制机制，主服务器负责记录所有数据的修改并将它们写入二进制日志。然后，从服务器会连接到主服务器，读取这些日志并将它们应用到自己的数据库中，这样主从数据库就能保持一致。整个过程包括主服务器生成二进制日志、从服务器接收并保存到中继日志，再由SQL线程执行这些变更。这种同步可以分为异步、半同步和组复制，不同模式有不同的性能和数据一致性保障。

## 3. MySQL主从同步延迟的原因和解决方法

### 口语化回答

MySQL主从同步延迟是指从服务器跟不上主服务器的更新速度，可能由主服务器负载过高、从服务器性能瓶颈、网络延迟、大事务以及锁争用等因素引起。解决办法包括优化主服务器和从服务器的性能、提高网络带宽、拆分大事务、调整并行复制配置、使用半同步复制等措施。通过这些方法，可以有效减少延迟，确保数据同步及时。

## 4. MySQL的全复制、半复制、异步复制都是什么?

### 口语化回答

MySQL有三种复制模式：异步复制、半同步复制和全同步复制。异步复制是默认模式，主服务器提交事务后不需要等从服务器的确认，性能很高但可能会有延迟。半同步复制会等待至少一个从服务器确认收到并写入日志后才完成事务，平衡了性能和数据一致性。全同步复制则等所有从服务器确认数据后才完成事务，数据一致性最强，但性能和延迟较差，适合对数据一致性要求极高的场景。

## 5. drop,delete与truncate的区别?

### 口语化回答

DROP、DELETE和TRUNCATE是处理数据库中数据和表结构的不同方式。`DROP`用于完全删除表或数据库，删除后无法恢复，性能较快但不可回滚。`DELETE`用于删除表中符合条件的行，可以回滚并触发DELETE触发器，但性能较慢。`TRUNCATE`则是快速删除表中所有行，但保留表结构，不会触发触发器，通常也不可回滚。整体上，DROP和TRUNCATE通常比DELETE更快。

## 6. 创建数据库表要注意什么?

### 口语化回答

创建数据库表时需要注意几个重要方面。首先，选择合适的数据类型以节省空间并提高查询效率。其次，定义主键以确保数据唯一性，每个表最好有一个不变的主键。然后，根据查询需求合理创建索引，但不要过多，避免影响写操作性能。表设计要遵循规范化原则，减少数据冗余，同时合理使用外键和约束来保持数据完整性。命名要清晰有意义，考虑大型表时可以使用分区来提高性能。选择合适的存储引擎，并为列设置合理的默认值。最后，保持良好的文档和注释，以提高可维护性。设计时还需要考虑未来的性能和扩展需求。

## 7. mvcc是什么?

### 口语化回答

MVCC（多版本并发控制）是一种管理数据库并发访问的方法，它通过维护数据的多个版本来提高并发性能和数据一致性。每次数据行被修改时，都会创建一个新版本，同时保留旧版本。每个事务在读取数据时只会看到它开始时的数据库状态，而不会受到其他事务修改的影响。MVCC的优势包括提高并发性、减少锁争用和提供一致性视图。然而，它也带来了一些挑战，比如存储开销、实现复杂性和写放大问题。

## 8. 什么是当前读与快照读(一致性读)?

### 口语化回答

当前读和一致性读是两种不同的读取数据的方式。当前读会读取最新的已经提交的数据版本，并且通常会加锁，确保在读取期间数据不会被其他事务修改。它适用于需要获取最新数据并且可能会修改数据的场景。比如，执行 `SELECT ... FOR UPDATE` 或者 `UPDATE` 操作时就是当前读。而一致性读会获取事务开始时的数据快照，确保读取的数据在事务期间保持一致，不受其他并发事务影响。它适用于只读操作，比如普通的 `SELECT` 查询，这种方式通过MVCC机制实现，不会加锁。

## 9. MVCC解决了什么问题?

### 口语化回答

MVCC（多版本并发控制）通过维护数据的多个版本，允许多个事务同时读取和写入数据，而不互相阻塞。这样可以提高系统的并发性，减少锁争用，避免读写冲突，提升读性能，还能实现更高的隔离级别。总的来说，MVCC 能让数据库在高并发环境下运行得更平稳，减少死锁问题，同时提供一致的数据视图。

## 10. Mysql的常用函数有哪些?

### 口语化回答

MySQL中有很多常用的函数，比如字符串处理函数如`CONCAT()`和`SUBSTRING()`，日期时间函数如`NOW()`和`DATE_FORMAT()`，以及数学函数如`ROUND()`和`FLOOR()`。还有一些常用的聚合函数，如`SUM()`、`AVG()`和`COUNT()`，用于统计数据的总和、平均值和记录数。它们帮助你在数据库查询时进行各种数据处理和分析。

## 11. Mysql的常用数据类型?

### 口语化回答

MySQL提供了多种数据类型来处理不同的数据需求。数值类型包括整数类型（如TINYINT到BIGINT）和浮点数类型（如FLOAT和DOUBLE），适用于各种数值数据。字符串类型包括CHAR、VARCHAR、TEXT等，处理不同长度的文本数据。二进制类型如BLOB和VARBINARY用于存储二进制数据。日期和时间类型如DATE、TIME、DATETIME等，用于处理日期和时间信息。JSON类型用于存储JSON格式的数据。枚举和集合类型（ENUM和SET）则允许存储预定义的多个值。还有一些特殊类型，如BOOLEAN表示布尔值，SERIAL用于自动递增的整数。

## 12. Mysql的char和varchar的区别?

### 口语化回答

`CHAR`和`VARCHAR`都是用来存储字符串的，但它们有些不同。`CHAR`是固定长度的，不管你存多少字符，都会占用定义的长度，比如`CHAR(10)`总是占用10个字符的空间，即使你只存了3个字符。`VARCHAR`则是可变长度的，只有实际存储的字符才占用空间，加上一个额外的字节来记录长度，因此对于变化大的字符串更节省空间。`CHAR`在检索和比较时速度较快，适合长度固定的字段，而`VARCHAR`更适合长度不固定的字段，但可能在性能上稍逊色。

## 13. MySQL中int(1)和int(10)的区别?

### 口语化回答

`INT(1)`和`INT(10)`的区别在于显示宽度，而不是存储大小或数值范围。`INT`类型的数值范围是固定的，不论是`INT(1)`还是`INT(10)`，都能存储相同的范围。显示宽度只在你使用`ZEROFILL`属性时才会有影响，这时MySQL会将数字填充到指定的宽度。例如，`INT(5) ZEROFILL`会将值`42`显示为`00042`。存储大小始终是4个字节，显示宽度对存储没有影响。

## 14. MySQL主键自增达到最大值会发生什么?你会怎么调整?

### 口语化回答

当主键自增达到最大值时，插入新记录会报错，比如`ERROR 1062 (23000): Duplicate entry`。为了应对这种情况，你可以采取几种措施。首先，可以更改主键的数据类型，比如将`INT`改为`BIGINT`，这样可以支持更大的值。如果当前使用的是有符号类型，考虑切换到无符号类型以获得更大的正整数范围。其次，可以尝试重置自增值，但这要求确保没有重复的主键值，并可能需要删除或归档现有数据。对于大数据量的表，考虑将旧数据归档到其他表中。复用删除的主键值虽然可行，但通常不推荐，因为可能导致冲突。预防措施包括定期监控自增值，并在接近最大值时采取行动，和在设计数据库时合理规划主键的数据类型。

## 15. MySQL的blob和text有什么区别?

### 口语化回答

在MySQL中，`BLOB`和`TEXT`都是用于存储大量数据的字段类型，但它们有一些关键的区别。`BLOB`用于存储二进制数据，如图片、音频或视频，它不会进行字符集转换。而`TEXT`则用于存储大文本数据，如文章或日志，存储时会受到字符集和排序规则的影响。两者都有四种类型，分别支持不同的数据大小，从最大255字节到4GB。`BLOB`不使用字符集和排序规则，适合存储二进制数据，而`TEXT`使用字符集和排序规则，适合存储文本数据。索引方面，`BLOB`和`TEXT`字段不能被索引，除非指定前缀长度。由于数据可能非常大，它们的性能可能会受到影响。在存储和检索时，`BLOB`不会进行字符集转换，而`TEXT`会进行字符集转换。

## 16. Mysql中什么是表分区?

### 口语化回答

表分区就是把一个大表的数据分成多个小的独立部分，每个部分可以独立存储。这种方式可以提高查询效率、简化管理，并且优化存储资源的使用。MySQL支持几种分区方式，比如按范围、列表、哈希或键分区。范围分区适合按日期分区，列表分区适合按特定值分区，哈希分区则适合均匀分布数据，键分区则使用MySQL自带的哈希函数。通过这种方式，可以更高效地处理大量数据。

## 17. 表分区与分表的区别?

### 口语化回答

表分区和分表虽然都用于管理大数据，但它们的实现方式和适用场景不同。**表分区**是把一个表的数据按照规则分成多个小部分，但这些分区在逻辑上仍然是一个表，由数据库内部处理，用户不需要关注。**分表**则是把一个表拆分成多个独立的表，这些表在逻辑上是独立的，应用程序需要处理数据如何分布。分区主要用于单个数据库的性能优化和数据管理，而分表则用于跨多个数据库的扩展和负载均衡。

## 18. MySQL什么情况下会产生死锁?

### 口语化回答

MySQL会在一些特定情况下产生死锁。比如，当两个事务以不同的顺序锁定相同的资源，或者在间隙锁下进行范围查询时，就可能导致死锁。此外，高并发下插入自增列、外键约束、锁升级以及混合不同类型的锁，也都可能引发死锁。如果事务长时间持有锁或并发事务过多，都容易导致死锁。为了解决这些问题，可以利用自动检测和回滚功能、合理设计事务、统一锁定顺序、减少并发事务等方法来预防和处理死锁。

## 19. Mysql死锁常见解决方案?

### 口语化回答

MySQL中的死锁是指多个事务相互等待对方持有的锁，导致无法继续执行。为了避免死锁，可以通过优化SQL语句减少锁持有时间，统一事务访问顺序来避免循环等待，使用适当的隔离级别和锁机制来减少锁冲突。此外，合理使用索引、启用和分析死锁日志、设置自动重试机制、调整锁等待超时、使用分区表和行级锁，以及避免热点更新，都能有效降低死锁发生的几率。

## 20. 为什么要使用视图?什么是视图?

### 口语化回答

视图是数据库中的虚拟表，用于简化复杂查询和提高数据安全性。它将一个或多个表的数据封装成一个逻辑表，使得用户只需访问视图而不必关心底层表的复杂性。视图能够提供数据抽象、实现数据重用，并在某些情况下优化查询性能，但需要注意视图的更新、性能影响以及依赖管理等问题。

## 21. 什么是存储过程?有哪些优缺点?

### 口语化回答

存储过程是数据库中的一组预编译的 SQL 语句和逻辑控制结构，它能提高性能、简化开发、增强安全性，但也有调试困难、可移植性差、性能瓶颈和维护复杂等缺点。存储过程能减少网络流量、提高代码重用率，但在不同数据库间移植难度大，且在高并发环境下可能导致性能问题。

## 22. union和union all区别?

### 口语化回答

`UNION` 和 `UNION ALL` 都是用来合并 SQL 查询结果的。`UNION` 会去除重复的行，因为它会额外排序来找出重复行，这样可能会稍微慢一些。`UNION ALL` 保留所有结果，包括重复的行，所以通常性能更好，尤其是在数据量很大的时候。

## 23. MySQL的binlog是什么?

### 口语化回答

MySQL 的二进制日志（binlog）记录了对数据库进行的所有更改操作。它的主要功能包括在发生数据丢失时恢复数据，通过复制机制将主服务器的更改同步到从服务器，以及审计和分析数据库上的操作。二进制日志由多个文件组成，MySQL 会自动生成和轮换这些日志文件。

## 24. MySQL的redolog是什么?

### 口语化回答

MySQL 的重做日志（redo log）是 InnoDB 存储引擎的一个重要组件，用于确保数据的持久性和一致性。它会记录所有对数据库的修改操作，并在实际写入数据文件之前先写入重做日志。这样，如果数据库崩溃或意外关机，重做日志可以帮助恢复未完成的事务，提高性能，并确保数据一致性。

---

## 25. MySQL除了binlog和redolog，还有其他的什么log吗

### 口语化回答

MySQL 除了 binlog 和 redo log，还有几个其他重要的日志：错误日志记录服务器的错误和重要事件，查询日志记录所有的 SQL 语句，慢查询日志记录执行时间长的查询，中继日志用于复制环境中同步数据，而撤销日志和表空间日志则分别用于事务回滚和表空间管理。这些日志对维护和优化 MySQL 数据库非常重要。