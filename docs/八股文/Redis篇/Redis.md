# Redis篇

::: tip Redis篇口语回答

本篇记录了关于 Redis 的口语话回答

:::

## Redis支持哪几种数据类型
好的面试官，redis 的基础数据类型，主要有五种，string，hash，list，set和zset。平时最常用的就是 string，可以缓存内容、做分布式锁等等，其次就是hash，比如缓存一些对象结构的数据，hash 就比较合理。假设缓存一个个人信息姓名，年龄，头像这些。传统的 string 需要进行序列化转json，hash 则可以直接拿到。zset 也用过，主要是做排行榜功能，利用分数的特性进行排序。主要就是这些，以上。

## Redis有哪些优点
好的，面试官 Redis 是现在非常常用的缓存，相比于其他的缓存，最大的一个优势就是高性能，redis 的速度非常快，操作都是毫秒级，吞吐量非常高，支持每秒数百万的请求。同时各种操作都基于内存进行，读写速度非常快。还有就是他提供了丰富的数据类型，像 string，hash，zset这些，在我们日常开发都非常常见的使用。还有一些高级数据类型，像 geo，bitmap 这些。另外就是redis 的持久化机制做的也比较好，不同的策略选择使其可以应对宕机等异常情况。配合分布式集群的支持，整体的可用性也非常高。以上。

## Redis常用类型的应用场景
好的，面试官，redis 的常用类型的应用场景，最常见的就是用来做各种各样的缓存，主要是 string 和 hash 用的会比较多。string 支持了各种方式的缓存，配合过期时间，非常的方便，string的 value 可以存json 等等这些东西，用起来也非常灵活。还有一个大的场景就是基于redis 实现的分布式锁，setnx 命令 天然支持锁的机制。针对一些对象的处理，hash 结构就比较常用，省去了json 序列化的性能消耗。另一种常用的就是 sortset，经常用来实现排行榜功能，也可以做一些延迟队列的操作。还有就是 set 可以用来做黑名单，list 可以实现一些简单的消息队列!

## Redis是单线程的吗
好的，面试官。这个问题其实是两个角度来看，我们通常说 redis 说单线程，是因为从接收到客户端的请求，然后 redis 进行内部操作，再返回结果。这个过程是单线程的。单线程的吞吐量可以达到 10w/s，来自redis 的官方数据，由于redis 的操作都是在内存中完成，所以性能的瓶颈时内存和带宽，而不是cpu。如果在这种情况下，使用多线程，反而又要去处理线程安全和数据竞争的问题，还有上下文切换的消耗。那么另一个角度就是除了redis 执行命令的时候，像持久化数据操作内存释放操作，这些是由多线程来进行实现的。在redis6.0 之后，为了减轻网络的性能瓶颈，还增加了多个io 线程来处理请求。也是一个比较大的优化。所以这个问题，两个角度来看，以上，

## Redis过期策略有哪些
好的，面试官，过期策略主要分为主动和被动，主动又分为定时、定期，被动就是常说的惰性清理。先说结论，redis采取的方案是定期+性配合的方式来进行实现。定期策略主要是通过周期性执行的函数来扫描即将过期的键，立马将其进行失效操作。这种方式比较消耗 cpu。于是产生了定期操作，没隔多少 ms 来进行执行，这种减少了 cpu 的消耗。也能比较准时的删除过期的键。算是定时的一种优化，比较难的点就是寻求平衡。最后就是拖性删除，所有的 key 即使过期了也不会立马删除，当这个键过期之后，下一次访问的时候，才会被删除，容易造成内存泄漏的问题。最后 oom 就会触发内存淘汰策略了，优点就是大大减轻了cpu 的压力。以上两种方式配合，能达到一个平衡。

## 什么是缓存穿透
好的，面试官，缓存穿透的最核心就是当高并发请求来的时候，但是key 在缓存中不存在的时候，就会请求数据库，如果数据库还是没有的话，就会返回，但是这个时候，由于没有数据，也不会存入到缓存中，下次请求过来还会重复这个操作。如果说这个 key 一直没有数据，就会不断的打到数据库中。这就是缓存穿透。缓存穿透主要可以通过缓存空值，布隆过滤器的方式来进行解决。常用的就是缓存空值当数据库也查询不到的时候，在缓存中将空值写入，这样后面的请求就会命中缓存，不会造成数据库的大压力。布隆过滤器比较适合一些固定值，来进行初步的过滤，这样可以减少误判率，同时减轻压力，以上，

## 什么是缓存击穿
好的，面试官，缓存击穿主要是高并发情况下，某个热点key突然失效或者未被缓存，导致大量请求直接穿透到后端数据库，从而使得数据库负载过高，甚至崩溃的问题。经常会有小伙伴和缓存穿透弄混，一个比较好的区分点就是可以理解为单 key，同时重建缓存需要时间。解决这个问题，一般常见的两种方案一个是互斥锁，在多请求情况下，只有一个请求会去构建缓存，其他的进行等待，这种主要是要考虑好死锁的问题和请求阻塞的问题。另一种就是设置一个逻辑过期时间，去进行异步的缓存更新，缓存本身永远不会过期，这样也就避免了击穿的问题。但是复杂性和逻辑时间的设置就比较考验设计。一般情况下互斥锁方案即可。以上。

## 什么是缓存雪崩
好的，面试官，缓存雪崩主要是在同一时间，系统大量缓存失效，这个时候的大量请求都要打到数据库，增加了数据库压力，导致数据库崩溃或者不可用，一般如果产生了雪崩，就是比较严重的后果。雪崩主要的解决方案，一方面是设置合理的缓存过期时间，不要让同一时间失效，尽量的分散。另一个方案就是可以在比如服务刚启动的时候，进行缓存的预热，防止刚启动的时候，大量请求打到数据库。另方面也要提升缓存架构的高可用，避免因为缓存服务的问题，导致请求打到数据库。以上。

## Redis的 setnx 和 setex 的区别
好的，面试官，setnx 和setex 都是在最基础的 set 命令上面所做的升级。setnx的一个特性就是如果 key 已经存在，在此放入会放不进去，这种特性也常常用来做分布式锁。如果 setnx 成功，则证明获取到锁成功，没有 set 成功，则证明获取锁失败。setex 只多了一个过期时间的概念，比如我希望本次放入的缓存3秒后自动失效，就可以通过这个命令来实现。

## Redis为什么这么快
好的，面试官，redis 的快主要得益于以下几个点，第一个就是纯内存的操作，相比磁盘来说，纯内存带来的速度提升非常大。其次就是合理的数据结构和数据编码设计。像不同的数据类型所对应的底层结构都会有变化，基本上作者让我们在 o1的杂度内就可以读取到我们想要的值。还有就是单线程，因为在内存，所以压力瓶颈一般在网络和 cpu，单线程完全足够，这使得redis 不需要考虑切换的消耗。以及redis 采取了 io 多路复用，减少了网络压力，提高了吞吐量。以上就是 redis 这么快的原因。

## Redis有哪些持久化方式
好的，面试官，主要是 rdb 和 aof的方式，另外也可以混合使用。rdb 主要是在指定的时间间隔内生成数据集的快照，并将其保存到磁盘上，生成一个rdb 格式的二进制文件，容易备份。恢复速度快，适合用于灾难恢复。AOF持久化方式是记录每一个写操作到日志文件中。Redis会将这些写操作以追加的方式写入到AOF文件中每次恢复的时候，进行重放。aof相比rdb 就是文件会大一些，回复速度一些但是数据丢失风险小。在实际中，一般可以选择混合互补的方式使用。以上。

## 什么是Redis事务机制
好的，面试官，redis 的事务机制不算是一个像 mysql 一样的正常的事务，只是保证了正常情况下的原子性，一场情况不提供回滚机制。redis 主要是将事务的命令放在一个队列，一起准备顺序执行。主要是 multi，exec，watch 命令配合使用。使用非常简单，先标记事务开始后，放入命令，再通过 exec执行即可。以上。

## Redis事务保证原子性吗,支持回滚吗
不支持。

先来回顾两个命令:

MULTI:开启一个事务。之后的所有命令都会被放入一个队列中，直到EXEC命令执行。

EXEC:执行之前队列中的所有命令。在MULTI和EXEC之间的命令会被放入一个队列中，直到EXEC命令执行时，这些命令才会按顺序执行。

在EXEC命令执行时，所有被MULTI命令包裹的命令会按顺序一次性执行。意味着在EXEC执行时，Redis会将所有命令作为一个整体进行处理

Redis保证单个命令的原子性，即每个命令在执行时是不可分割的。但是，Redis事务并不完全等同于传统关系型数据库的事务，

如果在EXEC执行过程中某个命令失败(例如，命令语法错误)，该命令会被跳过，但其他命令仍然会继续执行。这与关系型数据库的事务不同，后者通常会在某个命令失败时回滚整个事务。

Redis事务没有回滚机制。如果某个命令执行失败，已经执行的命令不会被撤销。

## 如果有大量的key需要设置同一时间过期,一般需要注意什么
大量的 key 同一时间过期，就是非常常见的缓存雪崩场景.

缓存雪崩是指在同一时间大量缓存key同时失效，导致大量请求直接涌向数据库或后端服务，可能引发系统崩溃或性能严重下降。

雪崩解决方案

- 过期时间随机化:在设置过期时间时，添加一个随机的偏移量，使得不同key的过期时间稍微不同，避免在同一时刻大量key同时失效。
  Random random=new Random();
  int baseExpiry=3680;//基础过期时间，单位为秒
  int randomOffset= random,nextInt(30);//随机偏移量，最大308秒
  int finalExpiry= baseExpiry + randomOffset;
  redisClient.set(key,value,finalExpiry);

- 分散过期时间:根据业务逻辑，将key的过期时间分散在不同的时间段内。例如，可以根据key的某些属性(如用户ID、商品ID等)分散设置过期时间。
- 缓存预热:在缓存失效前，提前预热缓存，确保缓存中始终有数据
- 监控报警机制
  使用Redis自身的监控工具或第三方监控工具(如Prometheus、Grafana等)监控缓存的命中率、延迟、内存使用等指标。设置报警规则，当缓存命中率下降或延迟增加时，及时发送报警通知，便于快速定位和解决问题。


## Redis常见性能问题和解决方案
好的，面试官，redis 常见性能问题主要有内存空间不足，大 key 问题，阻塞操作等等。像内存空间问题，主要发生在大规模的数据量下产生，针对这种我们可以采取数据结构层面的优化，或者集群模式的水平扩。大key 问题一般就是最初设计的时候，没有考虑清楚，导致业务日积月累，一个小的 key 变成了大 key。会导致我们的性能下降，耗时增加，这种需要从根上进行业务的梳理和处理拆分。还有就是阻塞，如果执行一些 keys 命令会大致阻塞，生产要避免进行这些操作。以上

## jedis 与 redisson 对比有什么优缺点
好的，面试官。jedis 是一个轻量级的redis 客户端，比较容易集成和使用。redisson 是后面的升级版框架，在分布式方面增加了很多的处理。最大的区别在于线程安全和分布式上面，jedis 需要一些操作来保证安全性，redission 则天然支持，内部封装了很多处理。还有就是集群方面 jedis 如果使用集群非常的麻烦，需要配置很多东西，redisson 则非常容易，天然支持。redisson还提供了很多现成的功能，分布式锁，限流等等这些，不需要再从头编写。如果业务比较简单，jedis 就够了。复杂的话大型项目还是建议使用redisson。以上。

## Jedis和Lettuce一些关键的区别

架构：Jedis是直连模式，多个线程操作是不安全的，每个线程都需要创建自己的Jedis实例。如果需要避免资源浪费，可以使用Jedis连接池。另一方面，Lettuce是基于Netty框架的事件驱动的Redis客户端，支持同步、异步和响应式编程。Lettuce的API是线程安全的，所以多个线程可以操作单个Lettuce连接来完成各种操作。
功能：Jedis相比Lettuce功能更加全面，在支持的数据类型上Jedis比Lettuce更多。Jedis支持基本的数据类型如String、Hash、List、Set、Sorted Set，同时还支持事务、Lua脚本、Pub/Sub、配置命令、批量操作等。而Lettuce则主要以同步、异步和响应式编程的方式对Redis进行操作。
可扩展性：Jedis如果需要扩展功能，通常需要修改Jedis源码。Lettuce则更容易进行扩展。
稳定性：对于连接高并发的场景，Lettuce要比Jedis更稳定，原因在于Lettuce底层采用Netty支持，可以更好的管理连接和实现异步操作。
安全性：Lettuce的安全性也要高于Jedis，主要在于Lettuce可以完全兼容Redis6.0，而且支持Redis的ACL规则，可以进行细粒度的权限控制。
同步与异步：Jedis是同步的，不支持异步操作。而Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的。
线程安全性：Jedis客户端实例不是线程安全的，需要每个线程一个Jedis实例，所以一般通过连接池来使用Jedis。相反，Lettuce的API是线程安全的，所以多个线程可以操作单个Lettuce连接来完成各种操作。
连接方式：如果不使用连接池，每次使用Jedis都需要新建一个连接，使用完后需要关闭连接，不然会资源泄露。而Lettuce基于Netty，可以在一个连接上并发处理多个命令。
综上所述，Jedis和Lettuce都有各自的优势和劣势，具体选择哪一个客户端需要根据具体的需求和使用场景来决定。

## Redis key 的过期时间和永久有效分别怎么设置

设置键的过期时间

- 使用EXPIRE命令，EXPIRE命令用于设置键的过期时间，以秒为单位
  EXPIRE key seconds
  例如:
  EXPIRE mykey 60 #设置 mykey 的过期时间为68秒

- 使用PEXPIRE命令，PEXPIRE命令用于设置键的过期时间，以秒为单位
  PEXPIRE key milliseconds
  例如:
  PEXPIRE mykey 60000 #设置 mykey 的过期时间为60000毫秒(即60秒)
  以上的两个区别就是秒级和毫秒级的区别

- 使用EXPIREAT命令，EXPIREAT命令用于设置键的过期时间为指定的 Unix 时间戳，以秒为单位。
  EXPIREAT key timestamp
  例如 :
  EXPIREAT mykey 1672531199 #设置 mykey 的过期时间为指定的 Unix 时间戳

- 使用PEXPIREAT命令，PEXPIREAT命令用于设置键的过期时间为指定的 Unix 时间戳，以秒为单位。
  PEXPIREAT key milliseconds-timestamp
  例如:
  PEXPIREAT mykey 1672531199000#设置 mykey 的过期时间为指定的 unix 时间戳(毫秒)

- 使用SET命令带选顶，SET命令可以在设置键值的同时指定过期时间。
  SET key value EX seconds
  SET key value PX milliseconds
  例如:
  SET mykey"value"EX60 #设置 mykey 的值为"value"并使其在68秒后过期SET mykey"value”Px68080 #设置 mykey 的值为"value”并使其在60008童秒(即68秒)后过期

设置键的过期时间

- 使用PERSIST命令，PERSIST命令用于移除键的过期时间，使其变为永久有效。
  PERSIST key
  例如:
  PERSIST mykey #移除 mykey 的过期时间，使其变为永久有效
  
## Redis内存用完了会发生什么
好的，面试官。redis 内存用完之后发生的现象主要取决于我们配置的内存回收策略。默认是noeviction，这个策略不会删除任何的键，当内存不足的时候，就会报错。这种策略，我们一般不使用。常见使用的就是lru，回收最近最少使用的有过期时间的键。其他的策略还比如 randow，可以回收随机的键。ttl按照最短的过期时间来进行回收。以上。

## Redis如何实现延时队列
好的，面试官。可以使用有序集合(Sorted Set)来实现延迟队列.有序集合中的每个元素有一个关联的分数, 可以用来表示任务的执行时间戳.

具体步骤如下:
* 添加任务到延迟队列
  将任务添加到有序集合中去,使用任务的执行时间作为分数(score)
  ```java
  String queueName = "delay_queue";
  String taskId = "task_1";
  long delay = 5000; // 延迟时间(毫秒)
  long executionTime = System.currentTimeMillis() + delay;
  Jedis jedis = newJedis("localhost");
  jedis.zadd(queueName, executionTime, taskId);
  jedis.close();
  
* 轮询延时队列并执行任务
  定期检查有序集合中的任务,找到那些执行时间已经到达或者超过当前时间的任务, 并执行这些任务.

## 看门狗机制的原理是什么
好的，面试官，在我们平常使用分布式锁的时候，一般会设置一个锁的过期时间那么如果锁过期的时候，业务还没执行完怎么办，于是就有了看门狗。看门狗机制是一种用于自动续约分布式锁的机制，确保在持有锁的客户端处理完业务逻辑之前，锁不会过期。当客户端获取到锁时，会在 Redis 中设置一个键和一个过期时间(默认30秒)。同时，Redisson 会启动一个后台任务，这个任务会定期检查锁的状态。看门狗任务会每隔一段时间，默认是锁的过期时间的1/3，即10秒，检查锁的状态。如果锁仍然被持有，看门狗任务会将锁的过期时间重置为初始值。这样，锁的过期时间不断被延长，直到客户端明确释放锁或者客户端挂掉。以上。

## 分布式锁的特点
好的，面试官，分布式锁，在日常的使用中，非常常见。主要要注意几个点，在某时刻，只能有一个获取到锁，失去链接或者异常情况，锁也能够释放。基于这种特点，主要有基于数据库的实现，redis实现，zookeeper的实现。数据库的实现方案基本不常见，这种方式性能很低，还容易影响业务。redis比较常见使用，主要是用 setnx 的特性来做。成功 set 进去，意味着上锁成功。失败意味着没有获取到锁，业务执行完成后，在通过 del来释放锁。一般会配合看门狗机制，来做异常的续约处理。以上。