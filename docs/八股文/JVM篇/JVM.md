# JVM

::: tip 说明

v1.0 2024/10/24

jvm是在整个八股背的阶段老是记得不熟

感觉这部分内容以后工作的重点，现在我觉得暂时了解如下即可，以后再补充

:::

常见的垃圾清理方法：

标记清除算法，复制算法，标记整理算法，分代算法

常见的垃圾收集器：

Serial GC, Parallel GC, CMS GC(Concurrent Mark Sweep), G1 GC(Garbage First), ZGC

## JVM的内存模型介绍一下

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp)

* 元空间：元空间的本质和永久代类似，都是对IM规范中方法区的实现。不过元空间与永久代之间最大的区别在于元空间并不在虚拟机中，而是使用本地内存。
* Java 虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧"的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表(基本数据类型和对象引用)、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。
* 本地方法栈：与虚拟机栈类似，区别是虚拟机栈执行Java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。
* 程序计数器：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器(对于多内核来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有“内存。
* 堆内存：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM 内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例:所有的对象实例及数组都在对上进行分配。**jdk1.8后，字符串常量池从永久代中剥离出来，存放在堆中。**

## 如何判断对象是否可以被回收？

**引用计数法和可达性分析法**是两种不同的内存管理和垃圾回收算法。引用计数法通过维护**引用计数器**来跟踪对象的引用数量，具有**实时性好、简单高效**等优点，但**存在循环引用**等问题；而可达性分析法则通过分析对象的引用关系来判断对象是否可达，从而决定对象是否可以被回收，具有准确性高、效率好等优点，是 JVM 中常用的垃圾回收算法之一

### 详细

#### 引用计数法

引用计数法(Reference Counting)是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。

当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。

优点：

**实时性好**：当没有引用指向一个对象时，该对象可以立即被回收，释放内存资源

**简单高效**：引用计数法是一种**相对简单**的内存管理技术，实现起来较为高效。

**无需沿指针查找**：与GC标记-清除算法不同，引用计数法无需从根节点开始沿指针查找。

缺点：

**循环引用问题**：当存在循环引用的情况下，对象之间的引用计数可能永远不会为零，导致内存泄漏的发生

**额外开销**：每个对象都需要维护一个引用计数器，这会带来一定的额外开销。

**不支持并发**：在多线程环境下，引用计数法需要进行额外的同步操作，以确保引用计数的准确性，可能导致性能损失。

#### 可达性分析法

通过分析对象的引用关系，判断对象是否可达，从而决定是否可以被回收。可达性分析算法是JVM垃圾回收中的一种算法。

工作原理

1. GC Roots：在Java中，GC Roots通常包括**虚拟机栈(栈帧中的本地变量表)中引用的对象、方法区(静态变
   量)中引用的对象、本地方法栈中JNI(Native方法)引用的对象**等。
2. 搜索过程：可达性分析算法从GC Roots开始，递归地访问所有可达的对象，并给它们打上标记。这个过程可以使用深度优先搜索(DFS)或广度优先搜索(BFS)等图遍历算法来实现。
3. 回收判定：如果一个对象到GC Roots没有任何引用链相连(即该对象从GC Roots不可达)，则证明该对象是不可用的，可以判定为可回收对象。

特点

1. 准确性：通过从GC Roots开始搜索引用链，可以准确地判断哪些对象是可回收的。
2. 效率：结合现代 JVM 的优化技术，如增量标记、并发标记等，可以提高可达性分析算法的效率。
3. 灵活性：可达性分析算法可以与不同的垃圾回收策略(如标记-清除、标记-整理等)结合使用，以适应不同的应用场景和硬件环境。

## JVM内存模型中的堆和栈有什么区别

* 用途：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。每当一个方法被调用，一个栈帧(stack frame)就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例(包括类的实例和数组)。当你使用 new 关键字创建一个对象时，对象的实例就会在堆上分配空间。
* 生命周期：栈中的数据具有确定的生命周期，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，对象会在垃圾回收机制(Garbage Colection,GC)检测到对象不再被引用时才被回收。
* 存取速度：栈的存取速度通常比堆快，栈操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。
* 存储空间：栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为**递归过深或局部变量过大**；堆的空间较大，动态扩展，由JVM管理。堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。
* 可见性：**栈中的数据对线程是私有的，每个线程有自己的栈空间**。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。

## 栈中存的到底是指针还是对象?
在JM内存模型中，栈(Stack)主要用于管理线程的局部变量和方法调用的上下文，而堆(Heap)则是用于存储所有类的实例和数组。

当我们在栈中讨论“存储”时，实际上指的是**存储基本类型的数据(如int,double等)和对象的引用，而不是对象本身**。

这里的关键点是，**栈中存储的不是对象，而是对象的引用**。也就是说，当你在方法中声明一个对象，比如`Myobject obj= new Myobject();`，这里的 obj 实际上是一个存储在栈上的引用，指向堆中实际的对象实例。这个引用是一个固定大小的数据(例如在64位系统上是8字节)，它指向堆中分配给对象的内存区域。

## 堆分为哪几个部分

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png)

* 新生代(Young Generation)：新生代分为Eden Space和Survivor Space。在Eden Space中，大多数新创建的对象首先存放在这里。Eden区相对较小，**当Eden区满时，会触发一次MinorGc(新生代垃圾回收)**。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0(Survivor 0)和S1(Survivor1)。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助**区分短暂存活的对象和长期存活的对象**。
* 老年代(Old Generation/Tenured Generation)：**一次或多次Minor GC后仍存活的对象会被移动到老年代**。老年代中的对象生命周期较长，因此Major Gc(也称为Full GC，涉及老年代的垃圾回收)发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
* 元空间(Metaspace)：从Java 8开始，永久代(Permanent Generation)被元空间取代，用于**存储类的元数据信息，如类的结构信息(如字段、方法信息等)。元空间并不在Java堆中，而是使用本地内存这解决了永久代容易出现的内存溢出问题**。
* 大对象区(Large Object Space/Humongous Objects)：在某些JVM实现中(如G1垃圾收集器)，为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

## 方法区中的方法的执行过程?
当程序中通过对象或类调用某个方法时的步骤如下：

1. 解析方法调用：JVM会根据方法的符号引用找到实际的方法地址(如果之前没有解析过的话)。

2. 栈帧创建：在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

3. 执行方法：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。

4. 返回处理：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。

## 方法区中有哪些东西

*String保存在字符串常量池中*

方法区：用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器（JIT）编译后的代码缓存等**

* 类信息：包括类的**结构信息、类的访问修饰符、父类与接口**等信息。
* 常量池：存储**类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池**。
* 静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。
* 方法字节码：存储类的方法字节码，**即编译后的代码**。
* 符号引用：存储类和方法的符号引用，是一种**直接引用**不同于直接引用的引用类型
* 运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。
* 常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。

## String s = new String(“abc”) 执行过程中创建多少个对象

`Strings= new String(“abc”)`

首先，new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。

其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它**是一个字符串常量**。在首次构建这个对象时，JVM拿字面量“abc”去**字符串常量池试图获取其对应String对象的引用**。于是在堆中创建了一个"abc”的String对象，并将其引用保存到字符串常量池中，然后返回;

所以，如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new string这个实例对象。如果abc这字符串常量存在，则只会创建一个对象。

## 引用类型有哪些?有什么区别?

* 强引用指的就是代码中普遍存在的赋值方式，比如用new关键字创建的对象实例。强引用关联的对象，永远不会被GC回收。
* 软引用可以用`SoftReference`来描述，指的是那些**有用但是不是必须要的对象**。系统在发生内存溢出前会对这类引用的对象进行回收。
* 弱引用可以用`WeakReference`来描述，他的强度比软引用更低一点，**弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够**
* 虚引用也被称作幻影引用，是最弱的引用关系，可以用`PhantomReference`来描述，他必须和`ReferenceQueue`（对应一个引用队列，发生GC的时候虚引用被回收，这时引用队列的计数器+1表示这个虚引用被GC掉了）一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。

## 内存泄漏和内存溢出的理解

内存泄漏：就是说程序中本该被清理掉的对象仍然在内存空间中存在而无法被回收，并且越来越多导致可用空间逐渐减小（使用静态数据结构比如HashMap或ArrayList存储对象且未清理、为取消对事件的监听、未停止的线程）

内存溢出：就是说像JVM申请内存空间时无法找到足够大的内存空间，最终引发OOM（深度递归，持久引用，大量对象创建）

## 创建对象的过程

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp)

在Java中创建对象的过程包括以下几个步骤:

* 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数**是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过**。如果没有，那必须先执行相应的类加载过程
* 分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。**对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java 堆中划分出来**。
* 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的值。
* 进行必要设置，比如对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
* 执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java 程序的视角看，对象创建才刚开始——**构造函数，即class文件中的方法还没有执行，所有的字段都还为零，对象需要的其地资源和状态信息还没有按照预定的意图构造好**。所以一般来说，执行 new 指令之后会接着执行方法，把对象**按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来**。

## 类加载器

**启动类加载器(Bootstrap class Loader)**：这是最顶层的类加载器，负责加载Java的核心库(如位于jre/lib/rt,jar中的类)，它是用C++编写的，是JVM的一部分。*启动类加载器无法被Java程序直接引用*。

**扩展类加载器(Extension Class Loader)**：它是Java语言实现的，**继承自ClassLoader类**，负责加载Java扩展目录(jre/lib/ext或由系统变量java.ext.dirs指定的目录)下的jar包和类库。*扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器*。

**系统类加载器(System Class Loader)/应用程序类加载器(Application Class Loader)**：这也是Java语言实现的，负责**加载用户类路径(ClassPath)上的指定类库**，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。

**自定义类加载器(Custom Class Loader)**：开发者可以根据需求定制类的加载方式，比如从网络加载class文件,数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是)Java动态性的一个重要体现。

这些类加载器之间的关系形成了**双亲委派模型**，其核心思想*是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载*。

### 双亲委派的作用

* 保证类的唯一性：通过委托机制，确保了所有加载请求都会**传递到启动类加载器**，*避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能*。
* 保证安全性：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。
* 支持隔离和层次划分：*双亲委派模型支持不同层次的类加载器服务于不同的类加载需求*，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分**有助于实现沙箱安全机制**，保证了各个层级类加载器的职责清晰，也便于维护和扩展。
* 简化了加载流程：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。

### 类加载过程

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp)

类从被加载到虚拟机内存开始到卸载出内存为止整个生命周期包括上图阶段

* 加载：通过类的全限定名（包名+类名），获取该类的`.class`文件的二进制字节流，**将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构**，在内存中生成一个代表该类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口
* 连接（验证、准备、解析三个阶段统称为【连接】）：
  * 验证：确保class文件中的字节流包含的信息符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证
  * 准备：为类中的*静态字段分配内存，并设置默认的初始值*，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了
  * 解析：解析阶段是虚拟机*将常量池的「符号引用」直接替换为「直接引用」的过程*。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用，那引用的目标必定已经存在于内存中了。
* 初始化：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的构造器方法(init)，要注意的是这里的构造器方法(init)并不是开发者写的，而*是编译器自动生成的*。
* 使用：使用类或者创建对象（类加载之后就能确定创建该类的实例对象要分配多大内存空间）
* 卸载：如果有下面的情况，类就会被卸载
  * 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例
  * 加载该类的ClassLoader已经被回收
  * 类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾回收机制

### 垃圾回收何时触发？

* 内存不足时：检测到堆内存不足，无法为新的对象分配内存，会自动触发垃圾回收。
* 手动请求：虽然垃圾回收是自动的，开发者可以通过调用system.gc()或Runtime.getRuntime().gc()**建议**JVM 进行垃圾回收。*不过这只是一个建议，并不能保证立即执行*。
* JVM参数：启动应用时可以通过 JVM 参数来调整垃圾回收的行为，比如:`-Xmx`(最大堆大小)、`-Xms`(初始堆大小)等。
* 对象数量或内存使用达到阈值：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。

### 垃圾分类

主要依赖两种主流的垃圾回收算法——**引用计数法**、**可达性分析法**

> 引用计数法

原理：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1;当引用失效时，计数器减1。计数器为0时，表示对象不再被任何变量引用，可以被回收。

缺点：**不能解决循环引用的问题**，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收（虽然思想简单，但是实现起来比较复杂，而且也可能有线程问题）

> 可达性分析算法

垃圾回收器**会从堆的根节点(如程序计数器、虚拟机栈、本地方法栈和方法区中的类静态属性等)，即gcroot**开始遍历对象图，标记所有可以到达的对象为存活对象，未被标记的对象则被认为是垃圾对象。

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png)

### 垃圾回收算法

* 标记-清除算法：标记-清除算法分为“标记“和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，*标记和清除的过程效率都不高*，另外一个就是，*清除结束后会造成大量的碎片空间，有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC*。
* 复制算法：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，*当内存不够时，将这一块内存中所有存活的复制到另一块上*。然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题：每次在申请内存时都只能使用一半的内存空间，内存利用率严重不足。
* 标记-整理算法：复制算法在 GC 之后存活对象较少的情况下效率比较高，但*如果存活对象比较多时，会执行较多的复制操作，效率就会下降*。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记“过程与“标记-清除算法"的标记过程一致，但标记之后不会直接清理，而是*将所有存活对象都移动到内存的一端，移动结束后直接清理掉剩余部分*。
* 分代回收算法：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的GC次数。对象创建时，一般在新生代申请内存，当经历一次 GC之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(**默认是 15，可以通过参数 -Xx:MaxTenuringThreshold 来设定**)后，如果对象还存活，那么该对象会进入老年代。

### minorGC\majorGC\fullGC的区别

> Minor Gc (Young GC)

作用范围：只针对年轻代进行回收，包括Eden区和两个Survivor区(S0和S1)

触发条件：当Eden区空间不足时，JVM会触发一次Minor Gc，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代(Old Generation)

特点：*通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短*。

> Major GC

作用范围：主要针对老年代进行回收，但不一定只回收老年代。

触发条件：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major Gc。

特点：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。

> Full GC

作用范围：对整个堆内存(包括年轻代、老年代以及永久代/元空间)进行回收。

触发条件：

1. 直接调用 system.gc()或 Runtime.getRuntime().gc()方法时，虽然不能保证立即执行，但会尝试执行Full GC
2. Minor Gc (新生代垃圾回收)时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。
3. 当永久代(Java 8之前的版本)或元空间(Java 8及以后的版本)空间不足时。

特点：Full GC是最昂贵的操作，因为它*需要停止所有的工作线程(Stop The World)，遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发*。

