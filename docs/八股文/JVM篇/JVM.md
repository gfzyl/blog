# JVM

常见的垃圾清理方法：

标记清除算法，复制算法，标记整理算法，分代算法

常见的垃圾收集器：

Serial GC, Parallel GC, CMS GC(Concurrent Mark Sweep), G1 GC(Garbage First), ZGC

## 一次完整的垃圾回收机制？

### 垃圾分类

首先 jvm 在进行垃圾回收的过程，需要确定哪些对象是垃圾对象，哪些对象是存活对象。类似于我们做事前的规划。具体的分类方法一般情况下，垃圾回收器**会从堆的根节点(如程序计数器、虚拟机栈、本地方法栈和方法区中的类静态属性等)，即gcroot**开始遍历对象图，标记所有可以到达的对象为存活对象，未被标记的对象则被认为是垃圾对象。进过标记后，分类成功。
### 垃圾查找

分类后，已知对象所处的状态，jvm 根据分类后对象，找出所有垃圾对象，以便进行清理。

不同的垃圾收集，其中的查找方式会产生相应的差异。随着 jdk 的升级与发展，还会产生更加高效的算法

### 垃圾清理

标记完成后，进行清理与删除。不同的垃圾收集器，清理的方式也不同，常见的有**标记-清除算法，复制算法，标记-整理算法，分代算法**。

需要注意的是，垃圾清理可能会引起应用程序暂停，不同的垃圾回收器通过不同方式减少这种暂停时间，从而提高应用程序的性能和可靠性。

## 如何判断对象是否可以被回收？

**引用计数法和可达性分析法**是两种不同的内存管理和垃圾回收算法。引用计数法通过维护**引用计数器**来跟踪对象的引用数量，具有**实时性好、简单高效**等优点，但**存在循环引用**等问题；而可达性分析法则通过分析对象的引用关系来判断对象是否可达，从而决定对象是否可以被回收，具有准确性高、效率好等优点，是 JVM 中常用的垃圾回收算法之一

### 详细

#### 引用计数法

引用计数法(Reference Counting)是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。

当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。

优点：

**实时性好**：当没有引用指向一个对象时，该对象可以立即被回收，释放内存资源

**简单高效**：引用计数法是一种**相对简单**的内存管理技术，实现起来较为高效。

**无需沿指针查找**：与GC标记-清除算法不同，引用计数法无需从根节点开始沿指针查找。

缺点：

**循环引用问题**：当存在循环引用的情况下，对象之间的引用计数可能永远不会为零，导致内存泄漏的发生

**额外开销**：每个对象都需要维护一个引用计数器，这会带来一定的额外开销。

**不支持并发**：在多线程环境下，引用计数法需要进行额外的同步操作，以确保引用计数的准确性，可能导致性能损失。

#### 可达性分析法

通过分析对象的引用关系，判断对象是否可达，从而决定是否可以被回收。可达性分析算法是JVM垃圾回收中的一种算法。

工作原理

1. GC Roots：在Java中，GC Roots通常包括**虚拟机栈(栈帧中的本地变量表)中引用的对象、方法区(静态变
   量)中引用的对象、本地方法栈中JNI(Native方法)引用的对象**等。
2. 搜索过程：可达性分析算法从GC Roots开始，递归地访问所有可达的对象，并给它们打上标记。这个过程可以使用深度优先搜索(DFS)或广度优先搜索(BFS)等图遍历算法来实现。
3. 回收判定：如果一个对象到GC Roots没有任何引用链相连(即该对象从GC Roots不可达)，则证明该对象是不可用的，可以判定为可回收对象。

特点

1. 准确性：通过从GC Roots开始搜索引用链，可以准确地判断哪些对象是可回收的。
2. 效率：结合现代 JVM 的优化技术，如增量标记、并发标记等，可以提高可达性分析算法的效率。
3. 灵活性：可达性分析算法可以与不同的垃圾回收策略(如标记-清除、标记-整理等)结合使用，以适应不同的应用场景和硬件环境。















