# JavaSE

## 八种基本数据类型注意

* java八种基本数据类型的字节数:1字节(byte、boolean)、2字节(short、char)、4字节(int、float)、8字节(long、double)

* 浮点数的默认类型为double(如果需要声明一个常量为float型，则必须要在未尾加上f或F)

* 整数的默认类型为int(声明Long型在末尾加上l或者L)

* 八种基本数据类型的包装类:除了char的是Character、int类型的是Integer，其他都是首字母大写

* char类型是无符号的，不能为负，所以是0开始的

## 用decimal而不用double

decimal 是精确计算，一般牵涉到金钱的计算，都使用Decimal

```java
BigDecimal num1 = new BigDecimal("0.1");
BigDecimal num2 = new BigDecimal("0.2");
BigDecimal sum = num1.add(num2);
BigDecimalproduct =num1.multiply(num2);
System.out.println("sum:+ sum");
System.out.println("Product:product");
```

## 面向对象的设计原则你知道有哪些吗

**面向对象编程中的六大原则**:

* 单一职责原则(SRP):一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
* 开放封闭原则(OCP):软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
* 里氏替换原则(LSP):子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个短形，但如果修改一个短形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
* 接口隔离原则(ISP):客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
* 依赖倒置原则(DIP):高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
* 最少知识原则 (Law of Demeter):一个对象应当对其他对象有最少的了解，只与其直接的朋友交豆。

## 非静态内部类和静态内部类的区别?
区别包括:

* 非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。
* 非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。
* 非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。
* 非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。
* 非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。

## 代码块——相当于另一种形式的构造器（对构造器的补充机制，可做初始化操作）

**代码块** 又称为 **初始化块**，属于类中的成员，即是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来，但和方法不同，没有方法名，没有返回没有参数，只有方法体，而且不通过对象或类显式调用，**而是加载类时，或创建对象时，隐式调用**。

```java
语法：[static]{
        任意代码
        }[;]
```

这里的[]表示可选，一般分号写；有static修饰的代码块叫静态代码块，否则是普通代码块

**应用场景：如果多个构造器中都有重复的 语句，可以抽取到初始化块中，提高代码对的重用性**

**不管** 调用哪个构造器，都会**先**调用代码块的内容，**<u>代码块的调用优先于构造器</u>**

```java
{
    System.out.println("电影屏幕放映");
    System.out.println("广告开始了");
    System.out.println("电影正式开始了");
}

public Movie(String name) {
    this.name = name;
}
```

**使用细节**:

1. **static代码块**：

   作用是对类进行初始化，随着类的加载而执行，并且 **只执行一次**；

   如果是 **普通代码块**，则 **每创建一个对象就执行一次**

2. **类什么时候被加载？（重要）**

   - 创建对象实例时（new） 
   - 创建子类对象实例，父类也会被加载（*如果有继承关系，父类的代码块先加载，因为构造器的优先顺序也是如此*）
   - 使用类的 **静态成员** 时（静态属性，静态方法）

3. 普通的代码块：

   **只有在创建对象实例时，会被隐式的调用，创建一次调用一次**

   如果只是使用类的静态成员时，普通代码块并不会执行。**它和类的加载没有毛关系**。

### 总结——创建一个对象时执行的顺序

1. **调用静态代码块和静态属性初始化**

   静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们的定义顺序调用

   *与加载相关*

2. **调用普通代码块和普通属性的初始化**

   普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按他们的定义顺序调用

3. **调用构造方法**

   ```java
   public class test {
       public static void main(String[] args) {A a = new A();}
   }
   class A{
       private int n2 = getN2();
       {
           System.out.println("A 普通代码块02");
       }
       private static int n1 = getN1();
       static {
           System.out.println("A 静态代码块01");
       }
       
       public int getN2(){
           System.out.println("getN2被调用");
           return 100;
       }
       public static int getN1(){
           System.out.println("getN1被调用");
           return 100;
       }
       public A() {
           System.out.println("无参构造器被调用");;
       }
   }
   输出：
       A 静态代码块01
   	getN1被调用
       getN2被调用
   	A 普通代码块02
       无参构造器被调用
   ```

   **总结一下**：类加载时，先加载与类相关（**静态**）-> 加载 **普通** 属性 -> 构造器

### 深入总结——创建一个子类对象时（继承关系）

::: warning

构造方法其实被 **隐式** 地调用了 **super()** 和 **调用普通代码块**

:::

1. **父类的静态代码块和静态属性（优先级一样，按定义顺序）**

2. **子类的静态代码块和静态属性（优先级一样，按定义顺序）**

   ps：**创建对象前现需要加载类**，先加载 **父类** 然后加载 **子类**，这个过程就是 **先把父类的静态相关** 加载出来然后把 **子类的静态相关** 加载出来

3. **父类的普通代码块和普通属性初始化（优先级一样，按定义顺序）**

   ps：这里子类构造器中隐式的 **super** 开始执行

   于是到达父类构造器，然后父类构造器中隐式的 **super** 执行（这里不再考虑上一级），因此执行父，即 **普通代码块和普通属性初始化**

4. **父类的构造方法**

   ps：父类构造器隐式的语句执行完毕，真正执行构造器中的语句

5. **子类的普通代码块和普通属性初始化（优先级一样，按定义顺序）**

   ps：子类构造器中的super语句执行完毕，回到子类构造器执行子类第二个隐式的调用，即**普通代码块和普通属性初始化**

6. **子类的构造方法**

   ps：执行子类构造器中的语句

## 深拷贝和浅拷贝

![](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp)

* 浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。
* 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对家。
