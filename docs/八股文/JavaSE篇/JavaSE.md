# JavaSE

## 1. 八种基本数据类型注意

* java八种基本数据类型的字节数:1字节(byte、boolean)、2字节(short、char)、4字节(int、float)、8字节(long、double)

* 浮点数的默认类型为double(如果需要声明一个常量为float型，则必须要在未尾加上f或F)

* 整数的默认类型为int(声明Long型在末尾加上l或者L)

* 八种基本数据类型的包装类:除了char的是Character、int类型的是Integer，其他都是首字母大写

* char类型是无符号的，不能为负，所以是0开始的

## 2. 为什么用decimal而不用double

decimal 是精确计算，一般牵涉到金钱的计算，都使用Decimal

```java
BigDecimal num1 = new BigDecimal("0.1");
BigDecimal num2 = new BigDecimal("0.2");
BigDecimal sum = num1.add(num2);
BigDecimalproduct =num1.multiply(num2);
System.out.println("sum:+ sum");
System.out.println("Product:product");
```

double会出现精度丢失的问题，double执行的是 **二进制浮点运算**，二进制有些情况下不能准确的表示一小数，就像十进制不能准确的表示1/3(1/3=0.3333..)，也就是说二进制表示小数的时候只能够表示能够用 **1/(2^n) 的和** 的任意组合，但是0.1不能够精确表示，因为它不能够表示成为 **1/(2^n)的和** 的形式。

可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。

而 Decimal 是 **精确计算** ,所以一般牵扯到金钱的计算,都使用 Decimal。

## 3. 面向对象的设计原则你知道有哪些吗

**面向对象编程中的六大原则**:

* 单一职责原则(SRP):一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子:考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
* 开放封闭原则(OCP):软件实体应该对扩展开放，对修改封闭。例子:通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
* 里氏替换原则(LSP):子类对象应该能够替换掉所有父类对象。例子:一个正方形是一个短形，但如果修改一个短形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
* 接口隔离原则(ISP):客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子:通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
* 依赖倒置原则(DIP):高层模块不应该依赖低层模块，二者都应该依赖于抽象;抽象不应该依赖于细节，细节应该依赖于抽象。例子:如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
* 最少知识原则 (Law of Demeter):一个对象应当对其他对象有最少的了解，只与其直接的朋友交豆。

## 4. 非静态内部类和静态内部类的区别?

区别包括:

* 非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。
* 非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。
* 非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。
* 非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。
* 非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。

### 非静态内部类可以直接访问外部方法，编译器是怎么做到的?
非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。
这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系从而实现直接访问外部方法的功能,

## 5. 代码块——相当于另一种形式的构造器（对构造器的补充机制，可做初始化操作）

**代码块** 又称为 **初始化块**，属于类中的成员，即是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来，但和方法不同，没有方法名，没有返回没有参数，只有方法体，而且不通过对象或类显式调用，**而是加载类时，或创建对象时，隐式调用**。

```java
语法：[static]{
        任意代码
        }[;]
```

这里的[]表示可选，一般分号写；有static修饰的代码块叫静态代码块，否则是普通代码块

**应用场景：如果多个构造器中都有重复的 语句，可以抽取到初始化块中，提高代码对的重用性**

**不管** 调用哪个构造器，都会**先**调用代码块的内容，**<u>代码块的调用优先于构造器</u>**

```java
{
    System.out.println("电影屏幕放映");
    System.out.println("广告开始了");
    System.out.println("电影正式开始了");
}

public Movie(String name) {
    this.name = name;
}
```

**使用细节**:

1. **static代码块**：

   作用是对类进行初始化，随着类的加载而执行，并且 **只执行一次**；

   如果是 **普通代码块**，则 **每创建一个对象就执行一次**

2. **类什么时候被加载？（重要）**

   - 创建对象实例时（new） 
   - 创建子类对象实例，父类也会被加载（*如果有继承关系，父类的代码块先加载，因为构造器的优先顺序也是如此*）
   - 使用类的 **静态成员** 时（静态属性，静态方法）

3. 普通的代码块：

   **只有在创建对象实例时，会被隐式的调用，创建一次调用一次**

   如果只是使用类的静态成员时，普通代码块并不会执行。**它和类的加载没有毛关系**。

### 总结——创建一个对象时执行的顺序

1. **调用静态代码块和静态属性初始化**

   静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们的定义顺序调用

   *与加载相关*

2. **调用普通代码块和普通属性的初始化**

   普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按他们的定义顺序调用

3. **调用构造方法**

   ```java
   public class test {
       public static void main(String[] args) {A a = new A();}
   }
   class A{
       private int n2 = getN2();
       {
           System.out.println("A 普通代码块02");
       }
       private static int n1 = getN1();
       static {
           System.out.println("A 静态代码块01");
       }
       
       public int getN2(){
           System.out.println("getN2被调用");
           return 100;
       }
       public static int getN1(){
           System.out.println("getN1被调用");
           return 100;
       }
       public A() {
           System.out.println("无参构造器被调用");;
       }
   }
   输出：
       A 静态代码块01
   	getN1被调用
       getN2被调用
   	A 普通代码块02
       无参构造器被调用
   ```

   **总结一下**：类加载时，先加载与类相关（**静态**）-> 加载 **普通** 属性 -> 构造器

### 6. 深入总结——创建一个子类对象时（继承关系）

::: warning

构造方法其实被 **隐式** 地调用了 **super()** 和 **调用普通代码块**

:::

1. **父类的静态代码块和静态属性（优先级一样，按定义顺序）**

2. **子类的静态代码块和静态属性（优先级一样，按定义顺序）**

   ps：**创建对象前现需要加载类**，先加载 **父类** 然后加载 **子类**，这个过程就是 **先把父类的静态相关** 加载出来然后把 **子类的静态相关** 加载出来

3. **父类的普通代码块和普通属性初始化（优先级一样，按定义顺序）**

   ps：这里子类构造器中隐式的 **super** 开始执行

   于是到达父类构造器，然后父类构造器中隐式的 **super** 执行（这里不再考虑上一级），因此执行父，即 **普通代码块和普通属性初始化**

4. **父类的构造方法**

   ps：父类构造器隐式的语句执行完毕，真正执行构造器中的语句

5. **子类的普通代码块和普通属性初始化（优先级一样，按定义顺序）**

   ps：子类构造器中的super语句执行完毕，回到子类构造器执行子类第二个隐式的调用，即**普通代码块和普通属性初始化**

6. **子类的构造方法**

   ps：执行子类构造器中的语句

## 7. 深拷贝和浅拷贝

![](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp)

* 浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。
* 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对家。

## 8. 在 Java 中实现单例模式（懒汉模式和饿汉模式）考虑多线程的环境。

### 1. 懒汉模式（Lazy Initialization）

懒汉模式的特点是延迟实例化，即只有在第一次使用时才创建对象。为了保证线程安全，可以使用**双重检查锁定（Double-Checked Locking）**，配合 `volatile` 关键字来确保变量的可见性。

```java
public class SingletonLazy {
    // 使用 volatile 确保多线程间的可见性
    private static volatile SingletonLazy instance = null;

    // 私有构造函数，防止外部实例化
    private SingletonLazy() {}

    // 提供线程安全的全局访问点
    public static SingletonLazy getInstance() {
        if (instance == null) {
            synchronized (SingletonLazy.class) {
                if (instance == null) {
                    instance = new SingletonLazy(); // 懒加载
                }
            }
        }
        return instance;
    }
}
```

**解释：**
- 使用 `volatile` 保证 instance 对所有线程的可见性，防止指令重排序。
- 双重检查锁定（`if (instance == null)`）确保只在实例未初始化时才进入同步块，提升性能。

### 2. 饿汉模式（Eager Initialization）

饿汉模式的特点是类加载时就创建实例，不管是否使用，故线程天生安全。但这种方式在某些情况下可能会造成不必要的资源浪费（比如程序中没有用到该实例）。

```java
public class SingletonEager {
    // 类加载时立即创建对象
    private static final SingletonEager instance = new SingletonEager();

    // 私有构造函数，防止外部实例化
    private SingletonEager() {}

    // 提供全局访问点
    public static SingletonEager getInstance() {
        return instance;
    }
}
```

**解释：**
- 实例在类加载时创建，利用类加载机制保证线程安全。
- 没有涉及到同步开销，调用速度快，但不管是否使用都会创建实例。

## 9. 自动装箱的弊端

自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。

```java
Integer sum=0;
for(int i=1000;i<5000;i++){Sum+=i;}
```

上面的代码 sum += i 可以看成 sum = sum + i ，但是 +这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下

```java
int result = sum.intValue() + i; 
Integer sum = new Integer(result);
```


由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。

## 10. Java为什么要有Integer

Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parselnt0等方法来专门处理int型相关的数据。

另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如Arraylist集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类也就是Integer才能被List所接受。所以Integer的存在是很必要的。

**泛型中的应用**

在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用`Collections.sort()`方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用 `Collections.sort()`方法。

```java
List<Integer>list =new ArrayList<>();
list.add(3);
list.add(1);
list.add(2);
Collections.sort(list);
System.out.println(list);
```

**转换中的应用**

在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。

```java
int i = 10;
Integer integer = new Integer(i);
String str=integer.tostring();
System.out.println(str);
```

**集合中的应用**

**Java集合中只能存储对象，而不能存储基本数据类型**。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。

```java
List<Integer>list = new ArrayList<>();
list.add(3);
list.add(1);
list.add(2);
int sum = list.stream().mapToInt(Integer::intValue).sum();
System.out.println(sum);
```

### Integer相比int有什么优点?

int是Java中的原始数据类型，而Integer是int的包装类。

Integer和 int 的区别:

**基本类型和引用类型** : 首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。*这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存*。在性能方面，基本数据类型的操作通常比相应的引用类型快。

**自动装箱和拆箱** : 其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。*自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型*。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。

**空指针异常** : 另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。*如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了nul值，而null值是无法进行自动拆箱的*。

### 那为什么还要保留int类型?

包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。

因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位M上，在开启引用压缩的情况下，一个nteger对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。

**也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效**。

### 说一下 integer的缓存

Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。

默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建个对象。

## 11. 怎么理解面向对象?简单说说封装继承多态
面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性(称为字段或属性)和行为(称为方法)。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。

Java面向对象的三大特性包括: **封装、继承、多态**:

### 封装:

封装是指将对象的属性(数据)和行为(方法)结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交瓦。封装的目的是增强安全性和简化编程，使得对象更加独立

### 继承:

继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。

### 多态:

多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态(重载)和运行时多态(重写)。它使得程序具有良好的灵活性和扩展性

### 补充

#### 多态体现在哪几个方面?

多态在面向对象编程中可以体现在以下几个方面:

* 方法重载 : 方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表(参数类型、数量或顺序不同)。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。示例:对于一个 add 方法，可以定义为 add(int a,int b)和 add(double a,double b)。

* 方法重写 : 方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。
  示例:在一个动物类中，定义一个 sound 方法，子类Dog可以重写该方法以实现 bark，而Cat 可以实现meow。

* 接口与实现 : 多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。
  示例:多个类(如Dog，cat )都实现了一个Animal接口，当用 Animal 类型的引用来调用 `makesound` 方法时，会触发对应的实现。

* 向上转型和向下转型 : 在Java中，可以使用父类类型的引用指向子类对象，这是 **向上转型**。通过这种方式，可以在运行时期采用不同的子类实现。

  **向下转型** 是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 `ClassCastException`

#### 多态解决了什么问题?

多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。

多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 `if-else` 语句等等

## 12. 抽象类和普通类区别?

* 实例化:普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。

  继承了抽象类的子类在实例化的时候，会**调用抽象类的构造器，但这不意味着抽象类被实例化了**

* 方法实现:普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。

* 继承:一个类可以继承一个普通类，而且可以继承多个接口;而一个类只能继承一个抽象类，但可以同时实现多个接口。

* 实现限制:普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。

## 13. Java抽象类和接口的区别是什么?

抽象类用于 **描述类的共同特性和行为**，可以有成员变量、构造方法和具体方法。适用于 **有明显继承关系** 的场景。

接口用于 **定义行为规范**，可以多实现，**只能有常量和抽象方法(java8 以后可以有默认方法和静态方法)**。适用于 **定义类的能力或功能**。

两者的区别:

**实现方式** : 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。

**方法方式** : 接口只有定义，不能有方法的实现，*java1.8中可以定义default方法体和静态方法，jdk9可以引入私有方法*（用于在接口中为默认方法或者其他私有方法提供辅助功能，这些方法不能被实现类访问，只能在接口内部使用），而抽象类可以有定义与实现，方法可在抽象类中实现。

```java
public interface Animal {
    void makeSound();
    
    default void sleep() {
        System.out.println("Sleeping...");
        logSleep();
    }
    
    private static logSleep(){
        System.out.println("Logging sleep");
    }
}
```

**访问修饰符**: 

接口成员变量默认为 `public static final`，必须赋初值，不能被修改；其所有的成员方法都是 `public abstract` 的，可以省略。

抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值;抽象方法被 abstract 修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。

**变量** : 抽象类可以包含实例变量和静态变量，而接口只能包含常量(即静态常量)

## 14. 泛型

泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。

泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。

## 15. Java 创建对象有哪些方式？

* new
* 使用 `Class` 类的 `newInstance()` 方法
* 使用 `Constructor` 类的 `newInstance()` 方法
* 使用 `clone()` 方法（实现了Cloneable接口）
* 使用反序列化：将对象序列化到文件或者流中，然后反序列化

## 16. New出的对象什么时候回收?
通过过关键字 new 创建的对象，由Java的垃圾回收器(Garbage Colector)负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。

具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况:

1. 引用计数法:某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
2. 可达性分析算法:从根对象(如方法区中的类静态属性、方法中的局部变量等)出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
3. 终结器(Finalizer):如果对象重写了 finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在 finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。

## 17. 什么是反射?

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java 语言的反射机制。

反射具有以下特性:

1. 运行时类信息访问:反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
2. 动态对象创建:可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过 Class类的newInstance()方法或Constructor对象的newInstance0方法实现的。
3. 动态方法调用:可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke0方法实现，允许你传入对象实例和参数值来执行方法。
4. 访问和修改字段值:反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。（首先要用setAccessable设置为true，这样私有属性的访问限制就会被打破）

### 反射在你平时写代码或者框架中的应用场景有哪些?
#### 加载数据库驱动

我们的项目底层数据库有时是用mysql，有时用oracle，需要 **动态地根据实际情况加载驱动类**

这时候我们在使用 JDBC 连接数据库时使用 `Class.forName()` 通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了，

```java
//DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());
Class.forName("com.mysgl.cj.jdbc.Driver");
```

#### 配置文件加载

Spring 框架的 IOC(动态加载管理 Bean)，Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。

Spring通过XML配置模式装载Bean的过程:

* 将程序中所有XML或properties配置文件加载入内存
* Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
* 使用反射机制，根据这个字符串获得某个类的Class实例
* 动态配置实例的属性

## 18. 能讲讲Java注解的原理吗?

注解本质是一个 *继承*了 `Annotation` 的特殊 **接口**，其 **具体实现类是Java运行时生成的动态代理类**。

我们 *通过反射获取注解时，返回的是Java运行时生成的动态代理对象*。通过代理对象调用自定义注解的方法，会最终调用 `AnnotationlnvocationHandler` 的 `invoke` 方法。该方法会从 `memberValues` 这个 `Map` 中索引出对应的值。而 `memberValues` 的来源是Java常量池

### Java注解的作用域?

注解的作用域(Scope)指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种:

1. 类级别作用域:用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别.
   继承关系、注释等。
2. 方法级别作用域:用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。
3. 字段级别作用域:用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。
4. 除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变是作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。

## 19. 介绍一下Java异常

![](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp)

Java的异常体系主要基于两大类:Throwable类及其子类。Throwable有两个重要的子类:Error和Exception，它们分别代表了不同类型的异常情况。

1. Error(错误):表示运行时环境的错误。**错误是程序无法处理的严重问题**，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，0utOfMemoryError、StackOverflowError等

2. Exception(异常):表示 **程序本身可以处理的异常条件**。

   异常分为两大类:

   非运行时异常:这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在。(FileNotFoundException)、类未找到(ClassNotFoundException)等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。

   运行时异常:这类异常包括运行时异常(RuntimeException)和错误(Error)。运行时异常由程序错误导致如空指针访问(NullPointerException)、数组越界(ArrayIndexOutOfBoundsException)等。运行时异常是不需要在编译时强制捕获或声明的。

## 20. try{return “a”} fianlly{return“b”}这条语句返回啥

`finally` 块中的 `return` 语句会 **覆盖** `try` 块中的 `return` 返回，因此，该语句将返回”b”

## 21. ==与 equals 有什么区别?
对于字符串变量来说，使用"`==`”和"`equals`"比较字符串时，其比较方法不同。"`==`"比较两个变量本身的值，即两个对象在内存中的首地址，“`equals`”比较字符串包含内容是否相同。

对于非字符串变量来说，如果没有对 `equals()` 进行重写的话，"`==`"和"`equals`”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。

`==`:比较的是两个字符串内存地址(堆内存)的数值是否相等，属于 **数值** 比较

`equals()`:比较的是两个字符串的内容，属于 **内容** 比较。

## 22. StringButter机StringBuild区别是什么?
区别:

String 是Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。

StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add方法，可以将字符串添加到已有序列的未尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。

StringBuilder 是JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减了开销。

### 线程安全:

StringBuffer:线程安全

StringBuilder:线程不安全
### 速度:

一般情况下，速度从快到慢为 StringBuilder>StringBuffer>String，当然这是相对的，不是绝对的。

### 使用场景:

操作少量的数据使用 String。

单线程操作大量数据使用 StringBuilder。

多线程操作大量数据使用 StringBuffer。

## 23. Stream流的并行API是什么?
是 `ParallelStream`。

并行流(`ParallelStream`)就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork/join 池来实现，即将一个任务拆分成多个“小任务“并行计算，再把多个“小任务”的结果合并成总的计算结果

![](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png)

对CPU密集型的任务来说，并行流使用 `ForkoinPool` 线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I/O密集的，并且任务数相对线程数比较大，那么直接用Parallelstream并不是很好的选择。

## 24. 怎么把一个对象从一个jvm转移到另一个jvm?
使用 **序列化和反序列化**: 将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 `ObjectOutputStream` 和 `ObjectlnputStream` 来实现。

使用 **消息传递机制** : 利用消息传递机制，比如使用消息队列(如 RabbitMa、Kafka)或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个 JVM。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。

使用 **远程方法调用(RPC)** : 可以使用远程方法调用框架，如 qRPC，来实现对象在不同IM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JM 上的对象的方法。

使用 **共享数据库或缓存** : 将对象存储在共享数据库(如 MySQL、PostgreSQl)或共享缓存(如 Redis)中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景,

## 25. 序列化和反序列化让你自己实现你会怎么做?

Java 默认的序列化虽然实现方便，但却 **存在安全漏洞、不跨语言** 以及性能差等缺陷。

* 无法跨语言 : Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的席列化框架，也没有实现Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。
* 容易被攻击 : Java 序列化是不安全的，我们知道对象是通过在 `ObjectlnputStream` 上调用 `readObject()` 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 `Serializable` 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。
* 序列化后的流太大 : 序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。

我会考虑用主流序列化框架，比如 **FastJson**、Protobuf来替代 Java 序列化。

如果追求性能的话，Protobuf席列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好，在编码和解码的性能方面也很高效。Protobuf的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。

## 26. 将对象转为二进制字节流具体怎么实现?
其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的 **处理和解析协议**，例如 **加密和解密**，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象

在Java中通过序列化对象流来完成序列化和反序列化:

* ObjectOutputStream:通过writeObject()方法做序列化操作
* ObjectInputStream:通过readObject0方法做反序列化操作。

只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常!

### 实现对象序列化:

1. 让类实现Serializable接口:

   ```java
   import java.io.serializable;
   public class Myclass implements Serializable{}// class code
   ```

2. 创建输出流并写入对象：

   ```java
   import java.io.FileOutputStream;
   import java.io.ObjectOutputStream;
   
   MyClass obj = new Myclass();
   try {
       FileOutputStream fileOut = new FileOutputstream("object.ser");
       ObjectOutputstream out = new objectOutputstream(fileOut);
       out.writeobject(obj);
       out.close();
       fileOut.close();
   }catch(IException e){
       e.printstackTrace();
   }
   ```

### 实现对象反序列化:

创建输入流并读取对象:

```java
import java.io.FileInputstream;
import java.io.0bjectInputstream;

MyClass newobj= null;
try {
    FileInputstream fileIn = new FileInputstream("object.ser");
    ObjectInputStream in = new ObjectInputstream(fileIn);
    newobj=(Myclass)in.readobject();
    in.close();
    fileIn.close();
}catch(IExceptionclassNotFoundException e){
    e.printstackTrace();
}
```

通过以上步骤，对象obi会被序列化并写入到文件"obiect.ser"中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。
