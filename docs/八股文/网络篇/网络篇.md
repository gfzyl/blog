# 网络篇

::: warning

本文取自JavaGuide和 **🐔鸡翅老哥**

一切为了方便自己背诵, 于是摘要过来

:::

## [HTTP 和 HTTPS 有什么区别？（重要）](#http-和-https-有什么区别-重要)

![HTTP 和 HTTPS 对比](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/http-vs-https.png)HTTP 和 HTTPS 对比

- **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
- **SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

## 说一下TCP/IP的四层网络模型

TCP/IP 四层模型简化了 OSI 七层模型，专专注于实际的网络通信实现。每层都有其特定的功能和协议，通过这些层次的协作，实现了复杂的网络通信任务。

* 网络接口层:处理物理网络上的数据传输，
* 网络层:负责数据包的路由和网络间通信。
* 传输层:提供端到端的数据传输服务，确保数据的可靠性和完整性
* 应用层:为应用程序提供通信服务，处理高层协议和数据格式。

## 七层网络模型是什么

OSI模型把网络通信的工作分为7层, 分别是物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层 和 应用层. 用于描述和标准化计算机网络通信的功能, 每一层都有特定的功能和协议

* 物理层:处理物理媒体上的数据传输，
* 数据链路层:提供点到点的数据传输和错误检测。(协议: PPP. ARP, Ethernet以太网)
* 网络层:负责数据包的路由和网络间通信。(协议: IP, ICMP, IGMP, OSPF, BGP)
* 传输层:提供端到端的数据传输服务，确保数据的可靠性和完整性(协议: TCP, UDP)
* 会话层:管理应用程序之间的会话。(协议: RPC)
* 表示层:处理数据的格式化、加密和解密(JPEG, GIF, MPEG数据格式)
* 应用层:为应用程序提供通信接口和服务。(协议: HTTP, HTTPS, FTP, SFTP, SMTP, POP3/IMAP, DNS, SSH)

## OSI分层的好处有哪些

* 标准化通信协议: 

  通过定义标准的通信协议, 各种不同的软硬件供应商可以开发互操作的网络设备和应用程序;

  公用一套标准化的协议,新旧设备之间互相兼容

* 模块化设计:

  每一层可以独立开发和优化, 使得专注于本层的功能, 无需关注起他层的实现, 层与层之间可以独立的修改和升级,不会影响到其他层

* 故障隔离和诊断

  通过分层结构可以更容易地定位到网络问题的具体层次, 从而针对该层次的问题对症下药, 也更有条理

* 简化网络设计和维护

  每一层都有自己明确的职责和功能, 分层结构十分清晰和明确,便于教学

* 增强网络安全

  可以在每一层上实施不同的安全措施

* 提高网络性能

  通过在不同层次上的优化可以提高整体性能;

  分层结构可以更容易地实现负载均衡和流量管理, 提高网络的效率和可靠性


## TCP两次握手不可以吗

三次握手的设计是确保 **双方都能正确的接受和发送数据**, 并且可以处理网络中的各种不可靠因素, 如果只是用两次握手, 可能会导致一些问题.
### 三次握手的过程

* 第一次握手(SYN): 

  **客户端发送** 一个SYN包给服务器, 请求建立连接,客户端进入SYS_SENT状态(**说明客户端可以发送消息**)

* 第二次握手(SYN-ACK):

  **服务器收到** 一个SYN包以后, **服务器发送** 一个SYN-ACK包给客户端, 表示同意建立连接, 并确认客户端的SYN包,服务器进入SYN-RECEIVED状态(**说明服务器可接收 可发送**)

* 第三次握手(ACK):

  **客户端收到** 一个SYN-ACK包以后, 发送一个ACK包给服务器, 确认服务器的的SYN-ACK包, 客户端和服务器都进入ESTABLISHED状态, 连接建立完成


### 两次握手的问题

如果只使用两次握手，可能会导致以下问题:

1. 旧的重复连接请求:
   假设一个旧的SYN包在网络中延迟了很长时间，最终到达服务器。服务器会认为这是一个新的连接请求并发送SYN-ACK包。
   如果没有第三次握手，服务器会认为连接已经建立，但客户端可能根本没有发起这个连接请求，导致服务器资源被浪费
2. 确认数据传输的可靠性
   **三次握手确保双方都能接收和发送数据**。第一次握手确认客户端能发送，第二次握手确认服务器能接收并发送，第三次握手确认客户端能接收。
   两次握手无法确认客户端是否能正确接收服务器的数据，可能导致数据传输的不可靠。

### 为什么tcp连接是3次，关闭是4次?

数据传输的完整性:关闭连接时，需要确保所有数据都已传输完毕，因此需要额外的确认步骤.

半关闭状态:TCP允许连接的一方在发送完数据后立即关闭发送通道，但仍然可以接收数据、这种半关闭状态需要额外的步骤来确认。

TIME_WAIT状态:为了确保对方收到最后的ACK包，并防止旧的重复数据包干扰新的连接，发送最后一个ACK的一方进入TIME_ WAIT状态。

## 如果建立连接后,客户端突然故障怎么办

### TCP Keepalive机制
TCP协议本身没有直接的机制来检测对端是否故障，但可以通过以下方式来处理这种情况:

1. **TCP Keepalive** :
TCP Keepalive是一种可选的机制，用于检测连接的对端是否仍然存在。
如果启用了TCP Keepalive，服务器会定期发送探测包(Keepalive探测)到客户端。
如果在一定时间内没有收到客户端的响应，服务器会认为客户端已经不可达，并关闭连接。
1. **应用层心跳机制**:
应用层可以实现自己的心跳机制，通过定期发送心跳消息来检测对端是否仍然存在。
如果在一定时间内没有收到心跳响应，服务器可以认为客户端已经故障，并采取相应措施。

### TCP超时和重传机制

TCP协议有自己的超时和重传机制，这些机制可以帮助检测连接是否已经断开:

1. 重传超时(RTO)
   TCP会为每个发送的数据包设置一个重传超时(RTO)
   如果在RTO时间内没有收到对端的确认，TCP会重传数据包，
   如果多次重传仍然没有收到确认，TCP会认为连接已经断开
2. 窗口探测(Zero Window Probe):
   如果对端的接收窗口为零(表示对端暂时无法接收数据)，TCP会定期发送窗口探测包。
   如果在一定时间内没有收到对端的响应，TCP会认为连接已经断开。

## 常见的HTTP状态码有哪些

* 1xx: 信息性响应

  100 Continue: 客户端应继续其请求

* 2xx: 成功

  200 OK 请求成功且服务器返回了请求的资源

  201 Created 请求成功并且服务器创建了新资源

  202 Accepted 请求已接受但尚未处理完成

  204 No Content 请求成功但是没有内容返回

* 3xx: 重定向

  301 Moved Permanently 请求的资源已经永久移动到新的URL

* 4xx: 客户端错误

  400 Bad Request 请求无效或者格式错误

  401 Unauthorized 请求需要身份验证

  403 Forbidden 服务器拒绝请求,客户端无权限

  404 Not Found 请求资源不存在

  405 Method Not Allowed 请求放错不被允许

* 5xx: 服务器错误

  500 Internal Server Error 服务器内部错误

  502 Bad Gateway 服务器作为网关或代理, 从上游服务器收到无效的响应

## 请求转发 Forward 和 重定向 Redirect 有啥区别

* 请求转发是服务器内部的请求转发, 服务器接收到客户端的请求以后将请求转发给另一个资源进行处理, 而 **客户端并不知道这一过程**

  特点: 

  * URL不变
  * 请求和相应对象在服务器内部传递, 不会发送新的HTTP请求
  * 原始请求和响应对象可以在转发的资源之间共享, 能够直接访问请求中的数据

  <u>适用于在同一个Web应用内部的资源之间转发请求; 需要在多个资源之间共享请求数据时</u>

* 重定向是客户端重定向. 服务器收到客户端请求以后 **发送一个重定向响应(HTTP状态码302或者其他) 和 新的URL 给客户端**, 客户端浏览器会 **自动** 发起对新的URL的请求

  特点: 

  * URL改变为新的URL
  * 服务器发送重定向响应后客户端发起一个新的HTTP请求
  * 请求数据不会自动传递, 需要通过URL参数或者其他方式传递

  <u>适用需要通知客户端浏览器进行新请求的情况, 比如跳转到外部资源 或者 不同的WEB应用</u>

## GET和POST的区别

* 用途和语义
  GET:用于请求从服务器获取数据。是寡等的(多次相同请求不会改变资源状态)。常用于获取资源，如网页、图片等。
  POST:用于向服务器发送数据以创建或更新资源。不是等的(多次相同请求可能会导致不同的结果)。常用于提交表单数据、上传文件等。

* 数据传输方式
  GET:数据通过URL传递，包括在查询字符串中(URL的一部分)。示例:`http://example.com/page?param1=value1&param2=value2` URL长度有限制(具体限制取决于浏览器和服务器)。
  POST:数据通过HTTP请求体传递。示例:在请求体中以键值对形式传递数据。没有明显的长度限制(限制取决于服务器配置)。

* 安全性
  GET:数据在URL中明文传输，容易被缓存和记录。不适合传输敏感信息(如密码)
  POST:数据在请求体中传输，不会显示在URL中。更适合传输敏感信息，但仍需通过HTTPS加密以确保安全
  
* 可见性和缓存
  GET:数据在URL中，用户和浏览器历史记录中可见。通常会被浏览器缓存。可以通过书签保存
  POST:数据不在URL中，不会在浏览器历史记录中显示。默认不会被浏览器缓存。不适合通过书签保存
  
* ldempotency(幂等性)
  GET:冥等的，多次请求不会改变资源状态。
  POST:不是篡等的，多次请求可能会导致资源状态变化(如多次提交表单)。
  
* 适用场景
  GET:获取资源或数据。传递少量非敏感数据。请求可以被缓存和书签保存的场景。
  POST:提交表单数据。上传文件。传递大量数据或敏感信息。需要对请求进行处理或改变服务器状态的场景

## TCP三次握手和四次挥手

::: tip 总结

**三次握手** :确保客户端和服务器双方都知道对方的接收和发送能力, 建立可靠的传输连接

**四次挥手** :确保 **双方都能完成** 数据传输, 并 **有序地** 终止连接, 确保所有数据都被正确接收

:::



具体过程

### 三次握手(建立连接)
1. 第一次握手(SYN):
   客户端向服务器发送一个SYN(同步序列号)报文段，请求建立连接。报文段中包含一个初始序列号(Sequence Number)，如SYN=1，Seq=X。

   ```Plain Text
   Client:SYN，seg=x
   ```

2. 第二次握手(SYN-ACK)
   服务器收到SYN报文后，确认收到，并向客户端发送一个SYN-ACK报文段。
   该报文段包含服务器的初始序列号(Seq=y)和对客户端SYN报文的确认号(Acknowledgment Number)，即Ack=x+1.

   ```Plain Text
   Server:SYN，ACK，Seq=y，Ack=x+1
   ```

3. 第三次握手(ACK)
   客户端收到SYN-ACK报文后，向服务器发送一个ACK报文段，确认收到服务器的SYN报文
   该报文段包含确认号(Ack=y+1)。

   ```Plain Text
   Client:ACK，Seg=x+1，Ack=y+1
   ```

**经过三次握手，客户端和服务器之间的连接正式建立，可以开始传输数据。**



### 四次挥手(终止连接)

1. 第一次挥手(FIN)
   客户端向服务器发送一个FIN(终止连接)报文段，表示客户端不再发送数据，但仍可以接收数据。
   报文段中包含一个序列号(Seq=u)。

   ```Plain Text
   Client:FIN，Seg=u
   ```

2. 第二次挥手(ACK)
   服务器收到FIN报文后，向客户端发送一个ACK报文段，确认收到客户端的FIN报文。
   该报文段包含确认号(Ack=u+1)。

   ```Plain Text
   Server:ACK，Seg=v，Ack=u+1
   ```

3. 第三次挥手(FIN):
   服务器向客户端发送一个FIN报文段，表示服务器也不再发送数据报文段中包含一个序列号(Seq=w)

   ```Plain Text
   Server:FIN，Seg=w
   ```

4. 第四次挥手(ACK)
   客户端收到服务器的FIN报文后，向服务器发送一个ACK报文段，确认收到服务器的FIN报文。
   该报文段包含确认号(Ack=w+1)。

   ```Plain Text
   Client:ACK，Seg=u+1，Ack=w+1
   ```

**经过四次挥手客户端和服务器之间的连接正式终止**

## TCP如何保证可靠性

* 三次握手(Three-Way Handshake)
  在建立连接时，TCP使用三次握手来确保双方都准备好进行通信。过程如下:
  i.客户端发送一个SYN(同步)包到服务器，表示请求建立连接。
  ii.服务器收到SYN包后，回复一个SYN-ACK(同步-确认)包，表示同意建立连接。
  iii.客户端收到SYN-ACK包后，发送一个ACK(确认)包，表示连接建立成功。
* 序列号和确认机制(Sequence Numbers and Acknowledgments):
  每个TCP段(数据包)都有一个序列号，接收方使用该序列号来重组数据并检测丢失的包。接收方在收到数据后，会发送一个ACK(确认)包，告知发送方已成功接收的数据序列号如果发送方在一定时间内没有收到ACK包，会重传该数据包。
* 重传机制(Retransmission Mechanism)TCP使用超时重传机制，如果发送方在超时时间内没有收到ACK包，会重传该数据包，TCP还使用快速重传机制，当接收方检测到数据包丢失时，会立即通知发送方进行重传，而不必等待超时。
* 流量控制(Flow Control)使用滑动窗口机制来控制数据流量，确保发送方不会发送超过接收方处理能力的数据量，滑动窗口大小由接收方在ACK包中告知发送方，发送方根据窗口大小调整发送速率。
* 拥塞控制(Congestion Control)4.TCP使用多种算法(如启动、拥塞避免、快速重传和快速恢复)来检测和避免网络拥塞。这些算法通过调整发送速率，防止网络过载，从而减少数据包丢失和延迟，数据校验和(Checksum)
* 每个TCP段都包含一个校验和字段，用于检测数据在传输过程中是否被损坏。
  接收方计算接收到的数据的校验和并与发送方的校验和进行比较，如果不匹配，则认为数据损坏并丢弃该段。

## 说说HTTP、TCP、Socket 的关系是什么

Socket(套接字)

Socket 是一种编程接口，用于在网络上进行通信。它抽象了网络通信的底层细节，使得程序员可以通过简单的接口进行网络通信。

Socket 可以基于不同的传输协议，如 TCP 和 UDP。常见的 Socket 类型包括流式套接字(基于 TCP)和数据报套接字(基于 UDP)。

在使用 HTTP 进行通信时，客户端和服务器会创建 TCP Socket，通过这些 Socket 进行连接和数据传输。

**关系总结**

* HTTP是应用层协议，用于定义客户端和服务器之间的请求和响应格式。
* TCP是传输层协议，提供可靠的、面向连接的通信服务，HTTP 依赖 TCP 来传输数据
* Socket是编程接口，抽象了网络通信的底层细节，应用程序通过 Socket 进行网络通信，使用 TCP 或 UDP作为传输协议。

## HTTP 长连接 和 短连接 的区别

**短连接(HTTP/1.0 默认)**

定义:短连接是一种在每次请求和响应之后立即关闭 TCP 连接的方式。

工作流程:

* 客户端发起一个 HTTP 请求
* b.服务器处理请求并发送响应。
* c.服务器关闭 TCP 连接。
* d.如果客户端需要再次请求数据，必须重新建立一个新的 TCP 

连接优点:

* 实现简单。
* 资源释放及时。

缺点:

* 每次请求都需要重新建立和关闭 TCP 连接，增加了连接建立的开销(如三次握手和四次挥手)，影响性能。
* 对服务器和网络的负担较大，尤其是在大量短时间请求的情况下

**长连接(HTTP/1.1 默认)**

定义:长连接是一种在多次请求和响应之间保持TCP连接打开的方式，允许复用同一个连接进行多个请求和响应。

工作流程:

* 客户端发起一个 HTTP 请求，并在请求头中包含Connection:keep-alive(HTTP/1.1 默认即为长道接)。
* 服务器处理请求并发送响应，同时保持连接打开，
* 客户端可以在同一个连接上发送后续请求，服务器继续响应，
* 连接在一段时间内保持打开状态，直到客户端或服务器主动关闭连接，或超时关闭。

优点:

* 减少了连接建立和关闭的开销，提高了传输效率，
* 减少了网络和服务器的负担，适合频繁的请求和响应

缺点:

* 需要管理长时间保持的连接，增加了资源管理的复杂性，
* 可能会占用服务器资源，尤其是在大量长时间未关闭的连接情况下。



## 什么是跨域问题 如何解决

参考:https://blog.csdn.net/wanxingahlal/article/details/140529856



## 如何理解HTTP协议是无状态的

HTTP(HyperText Transfer Protocol)是无状态的协议，这意味着每个请求都是独立的，与之前或之后的请求没有直接关联。服务器不会自动保存客户端的状态信息。每次客户端向服务器发送请求时，服务器处理完请求后，不会保留任何关于该客户端的请求状态的信息。

**无状态的具体含义**

* 独立性:
  每个 HTTP 请求都是独立的，服务器不会自动记住之前的请求信息。
  每次请求都必须包含所有必要的信息，以便服务器能够理解和处理请求
* 简化服务器设计:
  由于服务器不需要保存请求的状态信息，简化了服务器的设计和实现。
  服务器不需要为每个客户端维护会话状态，减少了内存和资源的消耗。

**无状态的优缺点**

优点

1. 简单性:
   无状态协议使得服务器的设计和实现更加简单，因为不需要管理和维护客户端的状态。
2. 可扩展性:
   由于服务器不需要保存状态信息，可以轻松地横向扩展(通过增加更多服务器来分担负载)。
3. 健壮性:
   无状态协议提高了系统的健壮性，因为每个请求都是独立的，服务器之间不需要共享状态信息

缺点

1. 需要重复传递信息:
   由于每个请求都是独立的，客户端需要在每次请求中重复传递必要的状态信息(如认证信息、会话ID等)
2. 客户端负担增加:
   为了保持状态，客户端需要在每次请求中包含足够的状态信息，这增加了客户端的负担

## **说一下 TCP 粘包是怎么产生的？怎么解决粘包问题的？**

TCP 粘包是指在使用 TCP 协议进行数据传输时，接收方在读取数据时无法正确区分出每个数据包的边界，导致多个数据包被粘在一起，或者一个数据包被拆分成多个部分。粘包和拆包问题主要是由于 TCP 协议的流式传输特性引起的。

TCP 粘包产生的原因

1. 发送方原因:
   发送方发送数据的速度快于接收方处理数据的速度，导致多个数据包被合并在一起发送。发送方调用 send 函数时，可能会将多个小数据包合并成一个大的数据包发送。
2. 接收方原因:
   接收方读取数据的速度快于发送方发送数据的速度，导致一个数据包被拆分成多个部分接收接收方调用 recv 函数时，可能会一次读取多个数据包，或者只读取一个数据包的一部分。

解决粘包问题的方法

解决粘包问题的关键是要在接收方正确地解析出每个数据包的边界。常见的解决方法包括以下几种:

1. 定长消息
   将每个消息的长度固定，这样接收方可以根据固定的长度来读取数据。
2. 特殊分隔符
   在每个消息的末尾添加特殊的分隔符，接收方可以根据分隔符来区分消息的边界
3. 消息头部包含长度信息
   在每个消息的头部添加一个固定长度的字段，用于表示消息的总长度。接收方首先读取消息头部，解析出消息的长度，然后根据长度读取完整的消息，
4. 应用层协议
   设计一个应用层协议，规定消息的格式和解析规则，使得接收方能够根据协议正确地解析出每个消息

## Session, Cookie, Token的区别

* **Session** :服务器端存储用户会话状态，通过 Session ID 识别用户。适用于需要在服务器端保持用户状态的场景。
* **Cookie** :客户端存储少量数据，可以用于会话管理和用户偏好设置。安全性较低，需要注意保护敏感信息
* **Token** :客户端存储的身份验证字符串，常用于无状态的身份验证机制。适用于分布式系统和需要跨域的场景。

## CDN 是什么

::: tip 说明

CDN(Content Delivery Network，内容分发网络)是一种分布式的网络基础设施，旨在通过将内容分发到多个地理位置分散的服务器节点上，从而加快用户访问网站内容的速度，提高网站的可靠性和可用性。CDN 的主要功能是将静态内容(如图片、视频、JavaScript、CSS 文件等)缓存到离用户最近的服务器节点，从而减少网络延迟和带宽消耗。

:::

CDN 的工作原理

1.内容缓存:网站的静态内容会被缓存到 CDN 的多个服务器节点上，这些节点通常称为边缘服务器(EdgeServers)。当用户第一次访问网站时，请求会被路由到最近的CDN 节点，该节点会从源服务器获取内容并缓存起来。

2.请求路由:当用户访问网站时，DNS 解析会将用户的请求路由到离用户最近的 CDN 边缘服务器。这样可以减少网络延迟，提高访问速度

3.内容分发:CDN 边缘服务器会根据用户的请求提供缓存的内容。如果某个边缘服务器没有缓存请求的内容它会从其他边缘服务器或源服务器获取内容并缓存。

4.负载均衡:CDN 使用负载均衡技术将用户请求分配到多个服务器，避免单个服务器过载，提高系统的可靠性和可用性。

CDN 的优势

1.提高访问速度:通过将内容缓存到离用户最近的服务器节点上，减少了数据传输的距离和网络延迟，从而加快了用户访问速度。

2.提高网站可用性:CDN 的分布式架构可以在某些服务器出现故障时，自动将请求路由到其他可用的服务器2提高网站的可靠性和可用性。

3.减轻源服务器负载:CDN 可以将大量的静态内容缓存到边缘服务器上，减少了源服务器的负载，提高了源服务器的性能。

4.节省带宽成本:通过缓存内容，CDN 可以减少源服务器的带宽消耗，从而降低带宽成本

5.抗 DDoS 攻击:CDN 的分布式架构和负载均衡技术可以有效防御分布式拒绝服务(DDoS)攻击，提高网站的安全性

CDN 的应用场景

1.网站加速:通过将网站的静态内容缓存到 CDN 节点上，提高用户访问网站的速度和体验

2.视频流媒体:CDN 可以将视频内容缓存到边缘服务器上，减少视频加载时间，提高视频播放的流畅度

3.软件分发:CDN 可以加速软件和补丁的下载，提高用户下载速度。

4.电子商务:CDN 可以提高电子商务网站的响应速度，提升用户购物体验。

5.全球内容分发:CDN 可以将内容分发到全球各地的服务器节点上，确保不同地区的用户都能快速访问内容

## 从输入URL到显示网页期间发生了什么

::: tip 前置参考

DNS域名解析: https://blog.csdn.net/2201_75444658/article/details/140272157

:::

1. URL输入与解析
   当用户在浏览器的地址栏中输入URL后，浏览器首先会检查这个URL是否完整，以及是否需要进行补全。浏览器会尝试从历史记录、书签等地方找到已经输入的字符串可能对应的URL，并提供智能提示，帮助用户补全或选择正确的URL。

2. DNS解析
   解析域名是访问网页的第一步。浏览器会查看本地hosts文件，检查是否有对应的IP地址记录。如果hosts文件中没有对应的IP地址，浏览器会发送DNS查询请求到本地DNS服务器。

   本地DNS服务器会检查其缓存，如果有相应的记录，则直接返回结果;否则，会向根DNS服务器发起查询逐级查找直至找到正确的IP地址。

3. 建立TCP连接
   在获取到目标服务器的IP地址后，浏览器会与服务器建立TCP连接。HTTP通信是通过TCP/IP协议族中的TCP协议来实现的。在HTTP/1.1版本中，默认情况下每个请求都会建立一个新的TCP连接;但在HTTP/2中，多个请求可以复用同一个TCP连接，这大大提高了网络效率。

4. 发送HTTP请求
   一旦TCP连接建立成功，浏览器会向服务器发送HTTP请求。请求包括请求行(如GET或POST方法、请求的URL、HTTP协议版本等)、请求头(包含有关客户端和请求的信息)以及请求体(在POST请求中，用于传输数据)

5. 服务器处理请求
   服务器收到请求后，会解析请求并查找相应的资源文件。这个过程可能涉及文件系统操作、数据库查询等如果服务器设置了重定向(如301或302重定向)，则会向浏览器发送重定向响应，告知浏览器新的URL地址。

6. 返回HTTP响应
   服务器处理完请求后，会向浏览器发送HTTP响应。响应包括状态行(如2000K表示请求成功)、响应头(包含有关服务器和响应的信息)以及响应体(即请求的资源文件)。

7. 浏览器解析并渲染页面
   浏览器收到服务器的响应后，会解析HTML、CSS和JavaScript等文件，构建DOM树和渲染树。在解析过程中，浏览器可能会发现HTML文件中嵌入了其他资源(如图片、视频等)，此时会发送额外的HTTP请求来获取这些资源。一旦所有资源都加载完成，浏览器就会渲染页面并显示在屏幕上，

8. 关闭TCP连接
   在HTTP/1.0中，服务器发送完响应后通常会关闭TCP连接;但在HTTP/1.1和HTTP/2中，连接可能会被保持打开状态以支持多个请求的复用，

## HTTPS的加密是什么

::: tip 说明

HTTPS(HyperText Transfer Protocol Secure)是HTTP的安全版本，用于在计算机网络上进行安全通信。HTTPS通过使用传输层安全(TLS，TransportLayerSecurity)协议来加密数据，从而保护通信的机密性和完整性。TLS是SSL(SecureSockets Layer)的后继版本。

HTTPS使用两种主要的加密算法:

1. 对称加密:
   对称加密使用相同的密钥进行加密和解密。常见的对称加密算法包括AES(Advanced Encryption Standard)、DES(Data EncryptionStandard)等。
   对称加密速度快，适合大数据量的加密
2. 非对称加密:
   非对称加密使用一对密钥:公钥和私钥。公钥用于加密，私钥用于解密常见的非对称加密算法包括RSA(Rivest-Shamir-Adleman)、ECC(Elliptic Curve Cryptography)等。
   非对称加密速度较慢，通常用于加密会话密钥等小数据量的信息，

HTTPS的安全特性

1. 数据加密:
   HTTPS通过加密数据传输，防止数据在传输过程中被窃听或篡改。
2. 数据完整性:
   HTTPS通过消息认证码(MAC，MessageAuthenticationCode)或哈希函数(如SHA-256)来确保数据的完整性，防止数据被篡改。
3. 身份验证:
   HTTPS通过数字证书验证服务器的身份，确保客户端连接的是合法的服务器，防止中间人攻击。

:::



**HTTPS的加密机制主要包括以下几个步骤**

1. 建立连接:
   客户端(例如浏览器)向服务器发送连接请求，并表明自己支持的加密协议和加密算法。
2. 服务器响应:
   服务器选择一个加密协议和加密算法，并发送给客户端，同时发送服务器的数字证书。数字证书包含服务器的公钥和由可信的证书颁发机构(CACertificate Authority)签名的服务器信息。
3. 验证证书:
   客户端验证服务器的数字证书，确认其合法性和真实性。这一步确保客户端连接的是正确的服务器，而不是中间人攻击者。
4. 生成会话密钥:
   客户端生成一个随机的会话密钥，并使用服务器的公钥对其进行加密。然后将加密后的会话密钥发送给服务器。服务器使用自己的私钥解密会话密钥
5. 安全通信:
   现在，客户端和服务器都拥有相同的会话密钥。接下来的通信使用对称加密算法(如AES)和这个会话密钥进行加密和解密
