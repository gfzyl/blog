# 链表系列

::: tip 经典算法

* 经典的快慢指针可以轻松搞定，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。

:::



## 旋转链表

题意: 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c23f6129f784cc8bae841930055e67f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1186&h=560&s=89428&e=png&b=fdfdfd)

```java
public ListNode rotateRight(ListNode head,int k){
    if(head == null || k == 0){
        return head;
    }
    ListNode temp = head;
    ListNode fast = head;
    ListNode slow = head;
	int len = 0;

    //当头结点不为空的时候一直遍历，然后 len++
    // 遍历完之后 head  为空
    while(head != null){
        head = head.next;
        len++;
    }

    if((k % len) == 0){
        return temp;
    }

    //从这里 fast 开始移动，取模是为了防止 k 大于 len 的情况出现
    while((k % len) > 0){
        k--;
        fast = fast.next;
    }

    while(fast.next != null){
        fast = fast.next;
        slow = slow.next;
    }

    ListNode res = slow.next;
    slow.next  = null;
    fast.next = temp;
    return res;
}
```

## 反转链表

### 1. 指定区间反转

::: tip 核心

找到 `left` 的前一个即为 `pre`, 这个 `pre` 是不会变化的

`cur` 代表 `pre` 的 `next`, 变化过程中,其实 `cur` 的相对位置是不变的, 永远都是以 `pre` 为头结点的第一个节点, 即 `cur` 永远指向 `pre.next`

从 `left.next` 起, 一直到 `right` 的每一个节点, 都进行 从 **“摘出来”** 到 **“挂上去”** 的操作

:::



![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/1ba1ec9b6f4a4a7b917ee77431d8023c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

反转的整体思想是，在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/b5423d73a9784de8a6b32232b7a95e4a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    ListNode pre = dummyNode;
    for(int i = 0; i< left - 1;i++){
        pre = pre.next;
    }
    ListNode cur = pre.next;
    ListNode next;
    for(int i = 0; i < right - left;i++){
        next = cur.next; // [!code focus]
        cur.next = next.next; // 到这里都是"摘出来" // [!code focus]
        next.next = pre.next; // [!code focus]
        pre.next = next; // 到这里都是"挂上去" // [!code focus]
    }
    return dummyNode.next;
}
```

### 2.两两交换链表中的节点

这是一道非常重要的问题，读者务必理解清楚。
LeetCode24.给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

![img](https://york-blog-1327009977.cos.ap-nanjing.myqcloud.com//APE-FRAME%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE/7712013fdda84a218a91666b84f1853d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

```java
public ListNode swapPairs(ListNode head) {
    // 最重要的点！！！对单链表而言，操作任何一个（或者一下操作多个节点），就是要找到紧随最前面的节点
    // 虽然链表元素的个数可能是奇数也能是偶数，但是只是结束的条件不一样，逻辑是一样的
    // 其实还是处理偶数个节点的反转，然后剩下的那个孤立的第奇数个节点就不用再操作了
    ListNode root = new ListNode(-1, head);
    ListNode cur = root;
    // 下面的逻辑就是一次动两步，然后期间交换相邻两节点
    while (cur.next != null && cur.next.next != null) {
        ListNode next = cur.next;
        ListNode nextNext = cur.next.next;
        // 对于每次循环，指定这段链表的头结点是后一个节点
        cur.next = nextNext;
        // 为了链接原有的结构
        next.next = nextNext.next;
        // 这段链表的新头节点指向新靠后的节点
        nextNext.next = next;
        // 移动两步（因为是交换，next的意义实际是nextNext的意义）
        cur = next;
    }
    // 这就是做新节点的好处，即可以操作方便，还可以知道操作完以后真正的头结点是谁
    return root.next;
}
```

