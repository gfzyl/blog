# 复习

::: tip letcode题目

下面全都是 letcode题目

题型合集:

| 题型   | 徽标                                          |
| ------ | --------------------------------------------- |
| 链表   | ![](https://img.shields.io/badge/链表-pink)   |
| 双指针 | ![](https://img.shields.io/badge/双指针-blue) |
| 回溯   | ![](https://img.shields.io/badge/回溯-green)  |
| 栈     | ![](https://img.shields.io/badge/栈-yellow)   |
|        |                                               |

重要程度:

| 重要程度 | 徽标                                          |
| -------- | --------------------------------------------- |
| 一般     | ![](https://img.shields.io/badge/一般-g)      |
| 中等     | ![](https://img.shields.io/badge/中等-orange) |
| 重要     | ![](https://img.shields.io/badge/重要-red)    |

:::

## 1.两数之和

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
	for (int i = 0; i < nums.length; i++) {
		int choose =  nums[i];
        int diff = target - choose;
        if(map.containsKey(diff)){
            return new int[]{i, map.get(diff)};
        }
        // 否则不包含目标值
        map.put(choose, i);
    }
    // 没从for里return说明就没有
    return null;
}
```

## 2.两数之和![](https://img.shields.io/badge/链表-pink)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
	ListNode root = new ListNode();
    ListNdoe curr = root;
    int carry = 0;
     // 循环中已经包括了节点都空但是还有进位的情况
    while (l1 != null || l2 != null || carry != 0) {
        int currV = (l1 == null ? 0 : l1.val)
            + (l2 == null ? 0 : l2.val)
            + carry;
        // 10进制的进位这样做更好
        if(currV > 9){
            currV -= 10;
            carry = 1;
        }else{
            carry = 0;
        }
        curr.next = new ListNdoe(currV);
        curr = curr.next;
        // 移动l1和l2的逻辑
        if (l1 != null) {
            l1 = l1.next;
        }
        if (l2 != null) {
            l2 = l2.next;
        }
    }
    return root.next;
}
```

## 3.无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> keyIndex = new HashMap<>();
    // 这里用这个map的意义，更重要的体现在，当遇到重复的元素的时候，下一次窗口的移动就直接能跳到导致重复的元素的后一个位置
    // 而且找到这个是用O(1)的速度，并不需要多次循环
    int length = s.length();
    int maxLength = 0; // 中间结果
    int lastIndex = 0; // 其实就是每一回找结果的时候的开头
    for (int i = 0; i < length; i++) {
        final char c = s.charAt(i);
        if (keyIndex.containsKey(c)) {
            lastIndex = Math.max(lastIndex, keyIndex.get(c) + 1); // keyIndex.get(c) + 1 导致重复的这个元素的下一个位置
        }
        keyIndex.put(c, i);
        int currLength = i - lastIndex + 1; // 记录当前长度
        maxLength = Math.max(maxLength, currLength);
    }
    return maxLength;
}
```

**体会**:

这个map存的就是某个字符 **最近一次** 出现的位置, 当指针指向的字符map中已经存在,

从map中取出 **该字符上次出现的下标 + 1**, 此时就是一个新的状态

## 11.盛水最多的容器![](https://img.shields.io/badge/双指针-blue)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的 **最大水量**。

**说明：**你不能倾斜容器。

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

```java
// 初始化： 双指针 i , j 分列水槽左右两端；
// 循环收窄： 直至双指针相遇时跳出；
// 选定两板高度中的短板，向中间收窄一格；
// 当你选择收窄时肯定是优先换更短的，因为短的可以换成大的或者小的
public int maxArea(int[] height) {
    int res = 0;
    int left = 0;
    int right = height.length - 1;
    while (left < right) {
        int leftHeight = height[left];
        int rightHeight = height[right];
        res = Math.max(res, (right - left) * Math.min(leftHeight, rightHeight));
        // 马上要进行下一次计算，但是下一次计算可以
        if (leftHeight < rightHeight) {
            while (left < right && height[left] <= leftHeight)
                left++;
        } else {
            while (left < right && height[right] <= rightHeight)
                right--;
        }
    }
    return res;
}
```

## 15.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> listNest = new ArrayList<>();
    if (nums.length < 3) {
        // 直接返回空
        return listNest;
    }
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i++) {
        Integer num1 = nums[i];
        if (num1 > 0) {
            // 因为是有序的，当nums[1]为正数时，其他两个数不可能相加是负数
            break;
        }
        if (i > 0 && nums[i] == nums[i - 1]) {
            // 避免重复
            continue;
        }
        Integer target = -num1;
        // 两个指针分别知道i的后一位和列表的最后一位
        int front = i + 1;
        int end = nums.length - 1;

        while (front < end) {
            int sumOfTwo = nums[front] + nums[end];
            if (sumOfTwo == target) {
                listNest.add(Arrays.asList(nums[i], nums[front], nums[end]));
                front++;
                end--;
                // 这里需要做一个防重复的处理
                while (front < end && nums[front] == nums[front - 1]) {
                    // 相同的数值，第一个指针从左到右前进一步
                    front++;
                }
                while (front < end && nums[end] == nums[end + 1]) {
                    // 相同的数值，第一个指针从右到左前进一步
                    end--;
                }

            } else if (sumOfTwo > target) {
                end--;
            } else {
                front++;
            }
        }
    }
    return listNest;
}
```

## 17.电话号码的字母组合![](https://img.shields.io/badge/回溯-green)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```java
// 数字键与拼音的对应集
final String[] m = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
List<String> res = new ArrayList<>();
// 存储中间结果
StringBuilder line = new StringBuilder();

public List<String> letterCombinations(String digits) {
    if (digits.length() == 0) {
        return new ArrayList<>();
    }
    process(digits, 0);
    return res;
}

/**
* @param digits 数字串
* @param index  处理到哪一个数字
*/
private void process(String digits, int index) {
    if (index == digits.length()) {
        // 表示当前已经处理完了所以数字组合
        res.add(line.toString());
        return;
    }
    // 当前index处表示的数字
    int digitsIndex = digits.charAt(index) - '0';
    char[] letter = m[digitsIndex].toCharArray();
    for (int i = 0; i < letter.length; i++) {
        line.append(letter[i]);
        process(digits, index + 1);
        line.deleteCharAt(line.length() - 1);
    }
}
```

## 19.删除链表倒数第N个节点![](https://img.shields.io/badge/链表-pink)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```java
/**
 * 相当于比着一把标尺，快指针和慢指针之间相隔n+1，这样快指针移动到最后一个节点的时候，慢指针就到了待删除节点的前一个
 */
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode root = new ListNode();
    root.next = head;
    // 其实就是为了n，新建一个空的头结点指向head，并且让head指向这个新的头结点，这样1
    head = root;
    ListNode res = head;
    while (head != null) {
        if (n >= 0) {
            n--;
        } else {
            // 当快指针移动了n次以后，慢指针再开始移动
            res = res.next;
        }
        head = head.next;
    }
    // 删除操作
    res.next = res.next.next;
    return root.next;
}
```

## 20.有效的括号![](https://img.shields.io/badge/栈-yellow)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

```java
public boolean isValid(String s) {
    if (s.length() % 2 != 0) {
        // 长度是奇数
        return false;
    }
    char[] charArray = s.toCharArray();
    // 也可以直接用最基础的Stack
    Deque<Character> stack = new LinkedList<>();
    Character t;
    for (char c : charArray) {
        // 左括号就放对应的右括号,这样就可以直接用相等比较了
        if (c == '{') {
            stack.addFirst('}');
        } else if (c == '(') {
            stack.addFirst(')');
        } else if (c == '[') {
            stack.addFirst(']');
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            // 这里直接出栈,省的后面比较还得出
            t = stack.pollFirst();
            // 就可以直接用字符是否相等来比较了
            if (t != c) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

## 21.合并两个有序链表![](https://img.shields.io/badge/链表-pink)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) {
        return list2;
    }
    if (list2 == null) {
        return list1;
    }
    // 根节点取决于哪个更小
    ListNode root = list1.val < list2.val ? list1 : list2;
    ListNode curr = root;
    if (list1.val < list2.val) {
        list1 = list1.next;
    } else {
        list2 = list2.next;
    }
    // 处理完两条链表的的起始位置
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            curr.next = list1;
            list1 = list1.next;
        } else {
            curr.next = list2;
            list2 = list2.next;
        }
        curr = curr.next;
    }
    // 这时还剩下一条链表,剩下谁就接谁
    if (list1 == null) {
        curr.next = list2;
    }
    if (list2 == null) {
        curr.next = list1;
    }
    return root;
}
```

## 22.括号生成![](https://img.shields.io/badge/回溯-green)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

```java
List<String> res = new ArrayList<>();

/**
* 根据括号的匹配原则,当左右数量相同时,只能添加左括号
* 当左括号小于n时,可以添加左括号
* 当右括号小于n时,可以添加右括号
* 左右括号的数量都必须得小于n
*/
public List<String> generateParenthesis(int n) {
    char[] line = new char[n * 2];
    process(line, 0, 0, 0, n);
    return res;
}

public void process(char[] line, int index, int leftCount, int rightCount, int n){
    if (index == n * 2) {
        // 说明左右括号的数量已经达到了n对
        res.add(new String(line));
        return;
    }
    // 这种情况必须写在最上面, 这样下面就不会出错
    if (leftCount == rightCount) {
        // 如果左右括号数相等,则此时只能加入左括号
        line[index] = '(';
        process(line, index + 1, leftCount + 1, rightCount, n);
        return;
    }
    if (leftCount < n) {
        line[index] = '(';
        process(line, index + 1, leftCount + 1, rightCount, n);
    }
    if (rightCount < n) {
        line[index] = ')';
        process(line, index + 1, leftCount, rightCount + 1, n);
    }
}
```

## 24.两两交换链表中的节点![](https://img.shields.io/badge/链表-pink)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```java
public ListNode swapPairs(ListNode head) 
    ListNode root = new ListNode(-1, head);
    ListNode cur = root;
    // 下面的逻辑就是一次动两步，然后期间交换相邻两节点
    while (cur.next != null && cur.next.next != null) {
        ListNode next = cur.next;
        ListNode nextNext = cur.next.next;
        // 对于每次循环，指定这段链表的头结点是后一个节点
        cur.next = nextNext;
        // 为了链接原有的结构
        next.next = nextNext.next;
        // 这段链表的新头节点指向新靠后的节点
        nextNext.next = next;
        // 移动两步（因为是交换，next的意义实际是nextNext的意义）
        // 也就是下一次逻辑的头节点
        cur = next;
    }
    // 这就是做新节点的好处，即可以操作方便，还可以知道操作完以后真正的头结点是谁
    return root.next;
}
```

## 25.K个一组翻转链表![](https://img.shields.io/badge/链表-pink)![](https://img.shields.io/badge/重要-red)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。



**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

```java
/*
k个一组反转
先拿到这K个长度的链表的尾节点，记录他的下一个节点，用于反转了这K个节点以后将新的头结点链接
*/
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode root = new ListNode(-1, head);
    ListNode pre = root;

    while (true) {
        ListNode t = nextTail(pre, k);
        if (t == null) {
            break;
        }
        ListNode next = t.next;
        ListNode tail = pre.next;
        t.next = null;
        ListNode newHead = reverse(pre.next);
        pre.next = newHead;
        tail.next = next;
        pre = tail;
    }
    return root.next;
}

/*
返回下一段K个长度的子链表的尾节点，如果不够K个，就返回null
*/
public ListNode nextTail(ListNode head, int k) {
    while (k > 0) {
        if (head != null) {
            k--;
            head = head.next;
        } else {
            return null;
        }
    }
    return head;
}

/*
反转链表
*/
public ListNode reverse(ListNode head) {
    ListNode lastNode = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = lastNode;
        lastNode = cur;
        cur = next;
    }
    return lastNode;
}
```















